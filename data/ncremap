#!/bin/bash

# ncremap, the NCO regridder and grid-file, map-file, and weight-generator

# Purpose: Generate weights (i.e., map-files) for and regrid (subsets of) netCDF files between different Swath, Curvilinear, Rectangular, and Unstructured data (SCRUD) horizontal grids, generate any required/requested global or regional rectangular grid, output SCRIP, UGRID, and/or skeleton data formats, and interpolate between any specified pure pressure or hybrid sigma/pressure grids

# Copyright (C) 2015--present Charlie Zender
# This file is part of NCO, the netCDF Operators. NCO is free software.
# You may redistribute and/or modify NCO under the terms of the 
# 3-Clause BSD License.

# You are permitted to link NCO with the HDF, netCDF, OPeNDAP, and UDUnits
# libraries and to distribute the resulting executables under the terms 
# of the BSD, but in addition obeying the extra stipulations of the 
# HDF, netCDF, OPeNDAP, and UDUnits licenses.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
# See the 3-Clause BSD License for more details.

# The original author of this software, Charlie Zender, seeks to improve
# it with your suggestions, contributions, bug-reports, and patches.
# Please contact the NCO project at http://nco.sf.net or write to
# Charlie Zender
# Department of Earth System Science
# University of California, Irvine
# Irvine, CA 92697-3100

# Prerequisites: Bash, NCO (also ESMF_RegridWeightGen and/or TempestRemap for full functionality)
# Script could use other shells, e.g., dash (Debian default) after rewriting function definitions and loops
# Debug with 'bash -x ncremap --dbg=dbg_lvl' where 0 <= dbg_lvl <= 5

# Source: https://github.com/nco/nco/tree/master/data/ncremap
# Documentation: http://nco.sf.net/nco.html#ncremap
# Additional Documentation:
# HowTo: https://acme-climate.atlassian.net/wiki/display/SIM/Generate%2C+Regrid%2C+and+Split+Climatologies+%28climo+files%29+with+ncclimo+and+ncremap
# E3SM Climatology Requirements: https://acme-climate.atlassian.net/wiki/display/ATM/Climo+Files+-+v0.3+AMIP+runs (includes useful discussion of normalization in comments section)
# Benchmarks: https://acme-climate.atlassian.net/wiki/spaces/ATM/pages/25231711/Validation+and+Benchmarking+of+Regridders

# Regridder works in one of four modes:
# 1. Free-will: Infer source and destination grids to generate map-file, then regrid
# 2. Old Grid: Use known-good destination grid to generate map-file then regrid
# 3. New Grid: Generate source-grid from ncks parameter string
# 4. Pre-Destination: Apply supplied map-file to all input files
# By default, ncremap deletes any intermediate grids and map-file that it generates
# Use Free-Will, Old-Grid, or New-Grid mode to process Swath-Like-Data (SLD) where each input may be a granule on a new grid, yet all inputs are to be regridded to the same output grid
# Use Pre-Destination mode to post-process models or analyses where all files are converted from the same source grid to the same destination grid so the map-file can be pre-generated and never change

# Insta-install:
# scp ~/nco/data/ncremap zender1@acme1.llnl.gov:bin
# scp ~/nco/data/ncremap zender1@aims4.llnl.gov:bin
# scp ~/nco/data/ncremap blues.lcrc.anl.gov:bin
# scp ~/nco/data/ncremap cheyenne.ucar.edu:bin
# scp ~/nco/data/ncremap compy.pnl.gov:bin
# scp ~/nco/data/ncremap cooley.alcf.anl.gov:bin
# scp ~/nco/data/ncremap cori.nersc.gov:bin_cori
# scp ~/nco/data/ncremap dust.ess.uci.edu:bin
# scp ~/nco/data/ncremap e3sm.ess.uci.edu:bin
# scp ~/nco/data/ncremap frazil.ess.uci.edu:bin
# scp ~/nco/data/ncremap rhea.ccs.ornl.gov:bin_rhea
# scp ~/nco/data/ncremap skyglow.ess.uci.edu:bin
# scp ~/nco/data/ncremap theta.alcf.anl.gov:bin_theta
# scp dust.ess.uci.edu:nco/data/ncremap ~/bin

# Set script name, directory, PID, run directory
drc_pwd=${PWD}
# Security: Explicitly unset IFS before wordsplitting, so Bash uses default IFS=<space><tab><newline>
unset IFS
# Set these before 'module' command which can overwrite ${BASH_SOURCE[0]}
# NB: dash supports $0 syntax, not ${BASH_SOURCE[0]} syntax
# http://stackoverflow.com/questions/59895/can-a-bash-script-tell-what-directory-its-stored-in
spt_src="${BASH_SOURCE[0]}"
[[ -z "${spt_src}" ]] && spt_src="${0}" # Use ${0} when BASH_SOURCE is unavailable (e.g., dash)
while [ -h "${spt_src}" ]; do # Recursively resolve ${spt_src} until file is no longer a symlink
  drc_spt="$( cd -P "$( dirname "${spt_src}" )" && pwd )"
  spt_src="$(readlink "${spt_src}")"
  [[ ${spt_src} != /* ]] && spt_src="${drc_spt}/${spt_src}" # If ${spt_src} was relative symlink, resolve it relative to path where symlink file was located
done
cmd_ln="${spt_src} ${@}"
drc_spt="$( cd -P "$( dirname "${spt_src}" )" && pwd )"
spt_nm=$(basename ${spt_src}) # [sng] Script name (unlike $0, ${BASH_SOURCE[0]} works well with 'source <script>')
spt_pid=$$ # [nbr] Script PID (process ID)

# https://support.hdfgroup.org/ftp/HDF5/releases/hdf5-1.10/hdf5-1.10.1/src/hdf5-1.10.1-RELEASE.txt
# "The file locking calls used in HDF5 1.10.0 (including patch1) will fail when the underlying file system does not support file locking or where locks have been disabled. To disable all file locking operations, an environment variable named HDF5_USE_FILE_LOCKING can be set to the five-character string 'FALSE'."
# 20200110 Qi Tang reports Cori batch scripts to generate map-files fail unless he sets this
# 20200131 Necessary whenever using OpenMP and netCDF4-linked library on any non-locking filesystem?
if [ -z "${HDF5_USE_FILE_LOCKING}" ]; then
    export HDF5_USE_FILE_LOCKING='FALSE'
fi # HDF5_USE_FILE_LOCKING

# Configure paths at High-Performance Computer Centers (HPCCs) based on ${HOSTNAME}
if [ -z "${HOSTNAME}" ]; then
    if [ -f /bin/hostname ] && [ -x /bin/hostname ]; then
	export HOSTNAME=`/bin/hostname`
    elif [ -f /usr/bin/hostname ] && [ -x /usr/bin/hostname ]; then
	export HOSTNAME=`/usr/bin/hostname`
    fi # !hostname
fi # HOSTNAME
# Default input and output directory is ${DATA}
if [ -z "${DATA}" ]; then
    case "${HOSTNAME}" in 
	constance* | node* ) DATA='/scratch' ; ;; # PNNL
	blues* | blogin* | b[0123456789][0123456789][0123456789] ) DATA="/lcrc/project/ACME/${USER}" ; ;; # ALCF blues compute nodes named bNNN, 36|64 cores|GB/node 
	*cheyenne* ) DATA="/glade/p/work/${USER}" ; ;; # NCAR cheyenne compute nodes named, e.g., r8i0n8, r5i3n16, r12i5n29 ... 18|(64/128) cores|GB/node (cheyenne login nodes 256 GB)
	compy* ) DATA="/qfs/people/${USER}/data" ; ;; # PNNL compy compute nodes all named nNNNN, 40|192 cores|GB/node (compy login nodes also 192 GB)
	cooley* | cc[0123456789][0123456789][0123456789] | mira* ) DATA="/projects/OceanClimate_2/${USER}" ; ;; # ALCF cooley compute nodes named ccNNN, 384 GB/node 
	cori* ) DATA="${SCRATCH}" ; ;; # NERSC cori compute nodes all named nidNNNNN, (32/68)|(96/128) cores|GB/node (knl/haswell) (login nodes 512 GB)
	rhea* | titan* ) DATA="/gpfs/alpine/world-shared/cli115/${USER}" ; ;; # OLCF rhea compute nodes named rheaNNN, 128 GB/node
	theta* ) DATA="/projects/ClimateEnergy_3/${USER}" ; ;; # ALCF theta compute nodes named fxm, 64|192 cores|GB/node 
	* ) DATA='/tmp' ; ;; # Other
    esac # !HOSTNAME
fi # DATA
# 20190423 Speed-up OpenMP processes on Cori KNL Intel builds (and possibly others)
# Environmental settings (e.g., OMP_PROC_BIND=spread or KMP_PROC_BIND=intel) may place all threads on same hardware core
# Problem only known to manifest when multiple instances of NCO are spawned on single node
OMP_PROC_BIND=false

# Ensure batch jobs access correct 'mpirun' (or, with SLURM, 'srun') command, netCDF library, and NCO executables and library
# 20170914 Entire block is identical between ncclimo and ncremap---keep it that way!
# hrd_pth could be a command-line option to control environment if this block placed below getopt() block (not trivial)
# 20190421 Change override default from opt-out to opt-in
# Leave NCO_PATH_OVERRIDE unset or set to 'No' to prevent NCO from executing next block that overrides PATH
# Set NCO_PATH_OVERRIDE to 'Yes' in environment to cause NCO to execute next block and to override PATH:
# export NCO_PATH_OVERRIDE='Yes'
hrd_pth='Yes' # [sng] Hard-code machine-dependent paths/modules if HOSTNAME in database
if [ "${hrd_pth}" = 'Yes' ] && [ "${NCO_PATH_OVERRIDE}" = 'Yes' ]; then
    # If HOSTNAME is not in database, change hrd_pth_fnd to 'No' in case-statement default fall-through
    hrd_pth_fnd='Yes' # [sng] Machine-dependent paths/modules for HOSTNAME found in database
    case "${HOSTNAME}" in 
	acme1* | aims4* )
	    export PATH='/export/zender1/bin:/usr/local/e3sm_unified/envs/base/envs/e3sm_unified_1.3.0/bin'\:${PATH}
            export LD_LIBRARY_PATH='/export/zender1/lib:/usr/local/e3sm_unified/envs/base/envs/e3sm_unified_1.3.0/lib'\:${LD_LIBRARY_PATH} ; ;;
	blues* | blogin* | b[0123456789][0123456789][0123456789] )
	    export PATH='/home/zender/bin:/soft/bebop/ncl/6.6.2/bin'\:${PATH}
	    export LD_LIBRARY_PATH='/home/zender/lib:/soft/bebop/ncl/6.6.2/lib'\:${LD_LIBRARY_PATH} ; ;;
	*cheyenne* )
	    # 20180112: Cheyenne support not yet tested in batch mode
	    if [ ${spt_nm} = 'ncremap' ]; then
		# On cheyenne, module load ncl installs ERWG in /glade/u/apps/ch/opt/ncl/6.4.0/intel/17.0.1/bin (i.e., ${NCARG_ROOT}/bin)
		module load ncl
	    fi # !ncremap
	    if [ -n "${NCARG_ROOT}" ]; then
		export PATH="${PATH}:/glade/u/apps/ch/opt/ncl/6.6.2/gnu/8.3.0/bin"
	    fi # !NCARG_ROOT
            export PATH='/glade/u/home/zender/bin'\:${PATH}
            export LD_LIBRARY_PATH='/glade/u/apps/ch/opt/netcdf/4.6.3/gnu/9.1.0/lib:/glade/u/apps/ch/opt/udunits/2.2.26/gnu/9.1.0/lib:/glade/u/apps/ch/opt/gsl/2.4/gnu/6.3.0/lib:/glade/u/home/zender/lib'\:${LD_LIBRARY_PATH} ; ;;
	compy* )
	    export PATH='/qfs/people/zender/bin'\:${PATH}
	    export LD_LIBRARY_PATH='/qfs/people/zender/lib'\:${LD_LIBRARY_PATH} ; ;;
	cooley* | cc[0123456789][0123456789][0123456789] )
	    # 20160421: Split cooley from mira binary locations to allow for different system libraries
	    # http://www.mcs.anl.gov/hs/software/systems/softenv/softenv-intro.html
	    soft add +mvapich2 
            export PBS_NUM_PPN=12 # Spoof PBS on Soft (which knows nothing about node capabilities)
	    export PATH='/home/zender/bin_cooley'\:${PATH}
	    export LD_LIBRARY_PATH='/home/zender/lib_cooley'\:${LD_LIBRARY_PATH} ; ;;
	cori* )
	    # 20160407: Separate cori from edison binary locations to allow for different system libraries
	    # 20160420: module load gsl, udunits required for non-interactive batch submissions by Wuyin Lin
	    # Not necessary for interactive, nor for CSZ non-interactive, batch submisssions
	    # Must be due to home environment differences between CSZ and other users
	    # Loading gsl and udunits seems to do no harm, so always do it
	    # This is equivalent to LD_LIBRARY_PATH method used for netCDF and SZIP on rhea
	    # Why do cori and rhea require workarounds for different packages?
	    # 20191023 NERSC incident INC0143724: ncl/6.5.0 provides broken ERWG, use 6.4.0 
	    if [ ${spt_nm} = 'ncremap' ]; then
		module load ncl/6.4.0
	    fi # !ncremap
	    if [ -n "${NCARG_ROOT}" ]; then
		export PATH="${PATH}:${NCARG_ROOT}/bin"
	    fi # !NCARG_ROOT
	    export PATH='/global/homes/z/zender/bin_cori'\:${PATH}
            export LD_LIBRARY_PATH='/global/homes/z/zender/lib_cori'\:${LD_LIBRARY_PATH} ; ;;
	mira* )
	    export PATH='/home/zender/bin_mira'\:${PATH}
	    export LD_LIBRARY_PATH='/soft/libraries/netcdf/current/library:/home/zender/lib_mira'\:${LD_LIBRARY_PATH} ; ;;
	rhea* )
	    # 20190827: Must guarantee finding mpirun
	    source ${MODULESHOME}/init/sh # 20150607: PMC Ensures find module commands will be found
	    if [ ${spt_nm} = 'ncremap' ]; then
		module load esmf
	    fi # !ncremap
            export PATH='/ccs/home/zender/bin_rhea'\:${PATH}
	    export LD_LIBRARY_PATH='/ccs/home/zender/lib_rhea:/ccs/proj/cli900/sw/rhea/e3sm-unified/base/envs/e3sm_unified_1.3.0/lib'\:${LD_LIBRARY_PATH} ; ;;
	theta* )
	    export PATH='/opt/cray/pe/netcdf/4.6.1.2/gnu/7.1/bin'\:${PATH}
	    export LD_LIBRARY_PATH='/opt/cray/pe/netcdf/4.6.1.2/gnu/7.1/lib'\:${LD_LIBRARY_PATH} ; ;;
	titan* )
	    source ${MODULESHOME}/init/sh # 20150607: PMC Ensures find module commands will be found
	    module load gcc
	    if [ ${spt_nm} = 'ncremap' ]; then
		# 20170831: Use module load ncl (6.3.0 lacks ERWG)
		module load ncl # 20170916 OK
	    fi # !ncremap
	    if [ -n "${NCARG_ROOT}" ]; then
		export PATH="${PATH}:${NCARG_ROOT}/bin"
	    fi # !NCARG_ROOT
            export PATH='/ccs/home/zender/bin_titan'\:${PATH}
	    export LD_LIBRARY_PATH='/opt/cray/netcdf/4.4.1.1/GNU/49/lib:/sw/xk6/udunits/2.1.24/sl_gcc4.5.3/lib:/ccs/home/zender/lib_titan'\:${LD_LIBRARY_PATH} ; ;;
	* ) # Default fall-through
	    hrd_pth_fnd='No' ; ;;
    esac # !HOSTNAME
fi # !hrd_pth && !NCO_PATH_OVERRIDE

# Test cases ($DATA/[grids/maps] refers to ~zender/data/[grids/maps] on Charlie's test machines)
# Map-only:
# ncremap -D 1 --devnull=No --nco='--dbg=1' --alg_typ=nco --grd_src=${DATA}/grids/ne30np4_pentagons.091226.nc --grd_dst=${DATA}/grids/cmip6_180x360_scrip.20181001.nc --map=${DATA}/maps/map_ne30np4_to_cmip6_180x360_nco.20190601.nc
# ncremap -D 1 --alg_typ=bilin   --grd_src=${DATA}/grids/oEC60to30.SCRIP.150729.nc --grd_dst=${DATA}/grids/t62_scrip.20181001.nc --map=${HOME}/map.nc
# ncremap -D 1 --alg_typ=tempest --grd_src=${DATA}/grids/oEC60to30.SCRIP.150729.nc --grd_dst=${DATA}/grids/t62_scrip.20181001.nc --map=${HOME}/map.nc
# ncremap -D 1 --alg_typ=tempest --grd_src=${DATA}/grids/oEC60to30.SCRIP.150729.nc --tpl=${DATA}/dstmch90/dstmch90_clm.nc --map=${HOME}/map.nc
# ncremap -D 1 --alg_typ=tempest --grd_src=${DATA}/grids/128x256_SCRIP.20160301.nc --tpl=${DATA}/dstmch90/dstmch90_clm.nc --map=${HOME}/map.nc
# Regrid:
# ls ${DATA}/ne30/raw/*1979*.nc | ncremap -m ${DATA}/maps/map_ne30np4_to_fv129x256_aave.20150901.nc -O ${DATA}/ne30/rgr
# ls ${DATA}/ne30/raw/*1979*.nc | ncremap -j 3 -m ${DATA}/maps/map_ne30np4_to_fv129x256_aave.20150901.nc -O ${DATA}/ne30/rgr # Batch-parallelism
# ncremap -a conserve -v FSNT -s ${DATA}/grids/ne30np4_pentagons.091226.nc -d ${DATA}/dstmch90/dstmch90_clm.nc -I ${DATA}/ne30/raw -O ${DATA}/ne30/rgr
# ls ${DATA}/essgcm14/essgcm14*cam*0007*.nc | ncremap -a conserve -M -d ${DATA}/dstmch90/dstmch90_clm.nc -O ${DATA}/ne30/rgr
# ncremap -a conserve -v FSNT -s ${DATA}/grids/ne30np4_pentagons.091226.nc -d ${DATA}/dstmch90/dstmch90_clm.nc -I ${DATA}/ne30/raw -O ${DATA}/ne30/rgr
# ncremap -P airs -v TSurfAir -g ${DATA}/grids/180x360_SCRIP.20150901.nc ${DATA}/hdf/AIRS.2014.10.01.202.L2.RetStd.v6.0.11.0.G14275134307.hdf ~/airs_out.nc
# ncremap -v CloudFrc_A -g ${DATA}/grids/180x360_SCRIP.20150901.nc ${DATA}/hdf/AIRS.2002.08.01.L3.RetStd_H031.v4.0.21.0.G06104133732.hdf ~/foo.nc
# ncremap -g ${DATA}/grids/180x360_SCRIP.20150901.nc ${DATA}/hdf/MOD04_L2.A2000055.0005.006.2014307165927.hdf ~/foo.nc
# ncremap -g ${DATA}/grids/180x360_SCRIP.20150901.nc ${DATA}/hdf/OMI-Aura_L2-OMIAuraSO2_2012m1222-o44888_v01-00-2014m0107t114720.h5 ~/foo.nc
# ncremap -v T -g ${DATA}/grids/180x360_SCRIP.20150901.nc ${DATA}/hdf/wrfout_v2_Lambert_notime.nc ~/foo.nc
# ncremap -v StepTwoO3 -d ${DATA}/hdf/cam_time.nc ${DATA}/hdf/OMI-Aura_L2-OMTO3_2015m0731t0034-o58727_v003-2015m0731t080836.he5.nc ~/foo.nc
# ncremap -v TSurfStd -G "--rgr grd_ttl='Default internally-generated grid' --rgr grid=${HOME}/rgr/ncremap_tmp_grd_dst.nc --rgr latlon=100,100 --rgr snwe=30.0,70.0,-130.0,-90.0" ${DATA}/sld/raw/AIRS.2014.10.01.202.L2.TSurfStd.Regrid010.1DLatLon.hole.nc ~/foo.nc
# ncremap -x TSurfStd_ct -g ${DATA}/grids/180x360_SCRIP.20150901.nc ${DATA}/sld/raw/AIRS.2014.10.01.202.L2.TSurfStd.Regrid010.1DLatLon.hole.nc ~/foo.nc
# CESM & E3SM:
# ncremap -s ${DATA}/grids/ne120np4_pentagons.100310.nc -g ${DATA}/grids/180x360_SCRIP.20150901.nc ${DATA}/ne120/raw/b1850c5_m2a.cam.h0.0060-01.nc ~/foo.nc
# Old MPAS filename conventions (until ~201609)::
# ncremap -P mpas -m ${DATA}/maps/map_oEC60to30_to_t62_bilin.20160301.nc ${DATA}/hdf/hist.ocn.0003-12-01_00.00.00.nc ~/foo.nc
# ncremap -P mpas -m ${DATA}/maps/map_mpas120_TO_T62_aave.121116.nc ${DATA}/hdf/hist.ice.0003-12-01_00.00.00.nc ~/foo.nc
# New MPAS filename conventions (as of ~201612):
# ncremap -P mpas -m ${DATA}/maps/map_oEC60to30_to_t62_bilin.20160301.nc ${DATA}/hdf/mpaso.hist.am.timeSeriesStatsMonthly.0001-01-01.nc ~/foo.nc
# ncremap -P mpas -m ${DATA}/maps/map_oEC60to30_to_t62_bilin.20160301.nc ${DATA}/hdf/mpascice.hist.am.timeSeriesStatsMonthly.0251-01-01.nc ~/foo.nc
# ncremap -P mpas --mss_val=-1.0e36 -s ${DATA}/grids/ais20km.150910.SCRIP.nc -g ${DATA}/grids/129x256_SCRIP.20150901.nc ${DATA}/hdf/ais20km.20180117.nc ~/foo.nc
# ncremap -P mpas --mss_val=-1.0e36 -s ${DATA}/grids/ais20km.150910.SCRIP.nc -g ${DATA}/grids/129x256_SCRIP.20150901.nc ${DATA}/hdf/mpasLIoutput.nc ~/foo.nc
# E3SM benchmarks:
# ncremap -v FSNT,AODVIS -m ${DATA}/maps/map_ne30np4_to_fv129x256_aave.20150901.nc ${DATA}/ne30/raw/famipc5_ne30_v0.3_00003.cam.h0.1979-01.nc ~/foo.nc
# ncremap -v FSNT,AODVIS -m ${DATA}/maps/map_ne30np4_to_fv129x256_mono.20190401.nc ${DATA}/ne30/raw/famipc5_ne30_v0.3_00003.cam.h0.1979-01.nc ~/foo.nc
# ncremap -v FSNT,AODVIS -m ${DATA}/maps/map_ne30np4_to_fv129x256_highorder.20190401.nc ${DATA}/ne30/raw/famipc5_ne30_v0.3_00003.cam.h0.1979-01.nc ~/foo.nc
# ncremap -v FSNT,AODVIS -m ${DATA}/maps/map_ne30np4_to_fv129x256_intbilin.20190401.nc ${DATA}/ne30/raw/famipc5_ne30_v0.3_00003.cam.h0.1979-01.nc ~/foo.nc
# ncremap -v FSNT,AODVIS -a conserve -s ${DATA}/grids/ne30np4_pentagons.091226.nc -g ${DATA}/grids/129x256_SCRIP.20150901.nc ${DATA}/ne30/raw/famipc5_ne30_v0.3_00003.cam.h0.1979-01.nc ~/foo.nc
# ncremap -v FSNT,AODVIS -a conserve2nd -s ${DATA}/grids/ne30np4_pentagons.091226.nc -g ${DATA}/grids/129x256_SCRIP.20150901.nc ${DATA}/ne30/raw/famipc5_ne30_v0.3_00003.cam.h0.1979-01.nc ~/foo.nc
# ncremap -v FSNT,AODVIS --rnr=0.99 --esmf_mth=idavg -s ${DATA}/grids/ne30np4_pentagons.091226.nc -g ${DATA}/grids/129x256_SCRIP.20150901.nc ${DATA}/ne30/raw/famipc5_ne30_v0.3_00003.cam.h0.1979-01.nc ~/foo.nc
# ncremap -v FSNT,AODVIS -a nco -s ${DATA}/grids/ne30np4_pentagons.091226.nc -g ${DATA}/grids/129x256_SCRIP.20150901.nc ${DATA}/ne30/raw/famipc5_ne30_v0.3_00003.cam.h0.1979-01.nc ~/foo.nc
# ncremap -v FSNT,AODVIS -a tempest -s ${DATA}/grids/ne30np4_pentagons.091226.nc -g ${DATA}/grids/129x256_SCRIP.20150901.nc ${DATA}/ne30/raw/famipc5_ne30_v0.3_00003.cam.h0.1979-01.nc ~/foo.nc
# Positional arguments:
# ncremap --var=FSNT,AODVIS --map=${DATA}/maps/map_ne30np4_to_fv129x256_aave.20150901.nc --drc_out=${DATA}/ne30/rgr ${DATA}/ne30/raw/famipc5_ne30_v0.3_00003.cam.h0.1979-??.nc
# Omit cell_measures:
# ncremap --no_cll_msr --var=FSNT,AODVIS -i ${DATA}/ne30/raw/famipc5_ne30_v0.3_00003.cam.h0.1979-01.nc -m ${DATA}/maps/map_ne30np4_to_fv129x256_aave.20150901.nc -o ~/foo.nc
# SGS (201909):
# ncremap -P elm -v FSDS,TBOT,GPP -m ${DATA}/maps/map_ne30np4_to_cmip6_180x360_aave.20181001.nc ~/elm_raw.nc ~/elm_sgs.nc
# ncremap -P mpasseaice --sgs_frc=timeMonthly_avg_iceAreaCell -m ${DATA}/maps/map_oEC60to30v3_to_cmip6_180x360_aave.20181001.nc ~/msi_raw.nc ~/msi_sgs.nc
# ncremap --sgs_frc=${DATA}/grids/sgs_landfrac_ne30.nc/landfrac -m ${DATA}/maps/map_ne30np4_to_cmip6_180x360_aave.20181001.nc ${DATA}/ne30/clm/TBOT_200001_200012.nc ~/foo.nc # External sgs_frc
# ncremap --vrb=3 --sgs_frc=landfrac --var=area,FSDS,landfrac,landmask,TBOT -m ${DATA}/maps/map_ne30np4_to_fv129x256_aave.20150901.nc ${DATA}/ne30/raw/F_acmev03_enso_camse_clm45bgc_ne30_co2cycle.clm2.h0.2000-01.nc ~/elm_sgs.nc # 20190918 1D->2D works
# ncremap --vrb=3 --sgs_frc=landfrac --var=area,FSDS,landfrac,landmask,TBOT -m ${DATA}/maps/map_t42_to_fv129x256_aave.20150901.nc ${DATA}/essgcm14/essgcm14.clm2.h0.0000-01.nc ~/t42_rgr.nc # 20190918 2D->2D
# ncremap --vrb=3 -p serial --sgs_frc=landfrac -s ${DATA}/grids/ne30np4_pentagons.091226.nc -g ${DATA}/grids/129x256_SCRIP.20150901.nc -O ${DATA}/ne30/rgr ${DATA}/ne30/raw/F_acmev03_enso_camse_clm45bgc_ne30_co2cycle.clm2.h0.2000-??.nc > ~/ncremap.out 2>&1 &
# ncremap --vrb=3 -a conserve --sgs_frc=aice --sgs_msk=tmask --sgs_nrm=100 --var=hi,uvel,aice,aisnap,albsno,blkmask,evap,evap_ai,fswabs,fswabs_ai,fswdn,fswthru,fswthru_ai,ice_present,snow,snow_ai,tarea,tmask,uarea -s ${DATA}/grids/gx1v7_151008.nc -g ${DATA}/grids/129x256_SCRIP.20150901.nc ${DATA}/hdf/ctl_brcp85c5cn_deg1.enm.cice.h.2050-07.nc ~/foo.nc # 20170525 normalization required to get mask right
# ncremap --vrb=3 -a conserve -P cice --var=hi,uvel,aice,aisnap,albsno,blkmask,evap,evap_ai,fswabs,fswabs_ai,fswdn,fswthru,fswthru_ai,ice_present,snow,snow_ai,tarea,tmask,uarea -s ${DATA}/grids/gx1v7_151008.nc -g ${DATA}/grids/129x256_SCRIP.20150901.nc ${DATA}/hdf/ctl_brcp85c5cn_deg1.enm.cice.h.2050-07.nc ~/foo.nc # 20170525 cice short-cut
# CICE/CESM on POP grid: full grid inferral (and thus conservative remapping) fails because masked vertices/cells missing, must use bilinear or supply grid-file for conservative
# ncremap -a bilinear -g ${DATA}/grids/129x256_SCRIP.20150901.nc ${DATA}/hdf/ctl_brcp85c5cn_deg1.enm.cice.h.2050-07.nc ~/foo.nc # 20170515: grid centers/bounds in non-masked regions suffice for bilinear interpolation
# ncremap -a conserve -s ${DATA}/grids/gx1v7_151008.nc -g ${DATA}/grids/129x256_SCRIP.20150901.nc ${DATA}/hdf/ctl_brcp85c5cn_deg1.enm.cice.h.2050-07.nc ~/foo.nc # 20170521: conservative requires supplied tri-pole grid for centers/bounds in masked regions
# File-format
# ncremap -v FSNT,AODVIS -s ${DATA}/grids/ne30np4_pentagons.091226.nc -d ${DATA}/dstmch90/dstmch90_clm.nc ${DATA}/ne30/raw/famipc5_ne30_v0.3_00003.cam.h0.1979-01.nc ~/foo.nc
# TempestRemap boutique:
# GenerateCSMesh --alt --res 30 --file ${DATA}/grids/ne30.g
# ncremap --dbg=1 -a se2fv_flx --src_grd=${DATA}/grids/ne30.g --dst_grd=${DATA}/grids/129x256_SCRIP.20150901.nc -m ~/map_ne30np4_to_fv129x256_mono.20180301.nc
# ncremap --dbg=1 -m ~/map_ne30np4_to_fv129x256_mono.20180301.nc ${DATA}/ne30/raw/famipc5_ne30_v0.3_00003.cam.h0.1979-01.nc ~/foo_fv129x256.nc
# ncremap --dbg=1 -a fv2se_stt --src_grd=${DATA}/grids/129x256_SCRIP.20150901.nc --dst_grd=${DATA}/grids/ne30.g -m ~/map_fv129x256_to_ne30np4_highorder.20180301.nc
# ncremap --dbg=1 -a fv2se_flx --src_grd=${DATA}/grids/129x256_SCRIP.20150901.nc --dst_grd=${DATA}/grids/ne30.g -m ~/map_fv129x256_to_ne30np4_monotr.20180301.nc
# ncremap --dbg=1 -m ~/map_fv129x256_to_ne30np4_highorder.20180301.nc ~/foo_fv129x256.nc ~/foo_ne30.nc
# Atmosphere->Ocean:
# ncremap --dbg=1 --a2o -a se2fv_flx --src_grd=${DATA}/grids/ne30.g --dst_grd=${DATA}/grids/129x256_SCRIP.20150901.nc -m ~/map_ne30np4_to_fv129x256_mono.20180301.nc
# Atmosphere->Atmosphere:
# ncremap --dbg=1 -a se2se --src_grd=${DATA}/grids/ne30.g --dst_grd=${DATA}/grids/ne30.g -m ~/map_ne30np4_to_ne30np4_se2se.20190301.nc
# Debugging and Benchmarking:
# ncremap -D 1 -d ${DATA}/dstmch90/dstmch90_clm.nc ${DATA}/sld/raw/AIRS.2014.10.01.202.L2.TSurfStd.Regrid010.1DLatLon.hole.nc ~/foo.nc > ~/ncremap.out 2>&1 &
# RRG (201807):
# ncremap -D 1 -a conserve --rnm_sng='_128e_to_134e_9s_to_16s' --bb_wesn='128.0,134.0,-16.0,-9.0' --dat_glb=${HOME}/dat_glb.nc --grd_glb=${HOME}/grd_glb.nc --grd_rgn=${HOME}/grd_rgn.nc ~/dat_rgn.nc ~/foo.nc > ~/ncremap.out 2>&1 &
# ncremap -D 0 --vrb=1 -a conserve --rnm_sng='_128e_to_134e_9s_to_16s' --bb_wesn='128.0,134.0,-16.0,-9.0' --dat_glb=${HOME}/dat_glb.nc --grd_glb=${HOME}/grd_glb.nc --grd_dst=${HOME}/grd_rgn.nc --grd_src=${HOME}/grd_src.nc --map=${HOME}/map.nc ~/dat_rgn.nc ~/foo.nc
# ncremap -D 0 --vrb=1 -a conserve --dat_glb=${HOME}/dat_glb.nc --grd_glb=${HOME}/grd_glb.nc --grd_dst=${HOME}/grd_rgn.nc --grd_src=${HOME}/grd_src.nc --map=${HOME}/map.nc ~/dat_rgn.nc ~/foo.nc
# ncremap -D 0 --vrb=1 -a conserve --dat_glb=${HOME}/dat_glb.nc --grd_glb=${HOME}/grd_glb.nc -g ${HOME}/grd_rgn.nc ~/dat_rgn.nc ~/foo.nc
# MWF (201807):
# ncremap -D 2 -P mwf --grd_src=${DATA}/grids/cmip6_180x360.g --grd_dst=${DATA}/grids/ne30.g --nm_src=cmip6_180x360 --nm_dst=ne30np4 --dt_sng=20190601 --drc_out=${DATA}/maps > ~/ncremap.out 2>&1 &
# ncremap -D 2 -P mwf --grd_src=${DATA}/grids/cmip6_720x1440.g --grd_dst=${DATA}/grids/ne120.g --nm_src=cmip6_720x1440 --nm_dst=ne120np4 --dt_sng=20190601 --drc_out=${DATA}/maps > ~/ncremap.out 2>&1 &
# ncremap -D 2 -P mwf --grd_src=${DATA}/grids/cmip6_180x360_scrip.nc --grd_dst=${DATA}/grids/ne30.g --nm_src=cmip6_180x360 --nm_dst=ne30np4 --dt_sng=20190601 --drc_out=$TMPDIR > ~/ncremap.out 2>&1 &
# ncremap -D 2 -P mwf --grd_src=${DATA}/grids/ocean.RRS.30-10km_scrip_150722.nc --grd_dst=${DATA}/grids/T62_040121.nc --nm_src=oRRS30to10 --nm_dst=T62 --dt_sng=20180901 --drc_out=$TMPDIR > ~/ncremap.out 2>&1 &
# ncremap -D 2 -P mwf --grd_src=${DATA}/grids/ocean.RRS.30-10km_scrip_150722.nc --grd_dst=${DATA}/grids/ne30.g --nm_src=oRRS30to10 --nm_dst=ne30np4 --dt_sng=20180901 --drc_out=$TMPDIR > ~/ncremap.out 2>&1 &
# ncremap -D 2 -P mwf --wgt_cmd='mpirun -np 12 ESMF_RegridWeightGen' --grd_src=${DATA}/grids/ocean.RRS.30-10km_scrip_150722.nc --grd_dst=${DATA}/grids/T62_040121.nc --nm_src=oRRS30to10 --nm_dst=T62 --dt_sng=20180901 --drc_out=$TMPDIR > ~/ncremap.out 2>&1 &
# Add depth (201901):
# ncremap -P mpas --dpt_fl=${DATA}/grids/mpas_refBottomDepth_60lyr.nc -m ${DATA}/maps/map_oEC60to30v3_to_cmip6_180x360_aave.20181001.nc ${DATA}/hdf/mpaso.lrz.hist.am.timeSeriesStatsMonthly.0001-12-01.nc ~/foo.nc
# Vertical interpolation (201903):
# ncremap -v lat,lon,FSNT,AODVIS,T,Q,U,V,Z3 --vrt_fl=${DATA}/grids/vrt_hyb_L72_ps.nc ${DATA}/ne30/raw/famipc5_ne30_v0.3_00003.cam.h0.1979-01.nc ~/foo # PS in "fat" template file
# ncremap -v lat,lon,FSNT,AODVIS,T,Q,U,V,Z3 --vrt_fl=${DATA}/grids/vrt_hyb_L72.nc ${DATA}/ne30/raw/famipc5_ne30_v0.3_00003.cam.h0.1979-01.nc ~/foo.nc # skinny template file
# ncremap -v lat,lon,FSNT,AODVIS,T,Q,U,V,Z3 --map=${DATA}/maps/map_ne30np4_to_fv129x256_aave.20150901.nc --vrt_fl=${DATA}/grids/vrt_hyb_L72.nc ${DATA}/ne30/raw/famipc5_ne30_v0.3_00003.cam.h0.1979-01.nc ~/foo.nc# Simultaneous horizontal/vertical regridding
# ncremap -v lat,lon,FSNT,AODVIS,T,Q,U,V,Z3 --vrt_xtr=mss_val --vrt_fl=${DATA}/grids/vrt_hyb_L72.nc ${DATA}/ne30/raw/famipc5_ne30_v0.3_00003.cam.h0.1979-01.nc ~/foo.nc # Missing-value extrapolation (mss_val|nrs_ngh) # Extrapolation results in missing values
# Time-varying hybrid input
# ncremap -v FSNT,AODVIS,T,Q,U,V,Z3 --map=${DATA}/maps/map_ne30np4_to_fv129x256_aave.20150901.nc --drc_out=${DATA}/ne30/rgr ${DATA}/ne30/raw/famipc5_ne30_v0.3_00003.cam.h0.1979-0[123].nc 
# ncrcat -O -v FSNT,AODVIS,T,Q,U,V,Z3 ${DATA}/ne30/rgr/famipc5_ne30_v0.3_00003.cam.h0.1979-0[123].nc ${DATA}/ne30/rgr/famipc5_ne30_v0.3_00003.cam.h0.197901_197903.nc
# ncremap --dbg=3 -v FSNT,AODVIS,T,Q,U,V,Z3 --vrt_fl=${DATA}/grids/vrt_prs_ncep_L17.nc ${DATA}/ne30/rgr/famipc5_ne30_v0.3_00003.cam.h0.197901_197903.nc ~/foo.nc

# dbg_lvl: 0 = Quiet, print basic status during evaluation
#          1 = Print configuration, full commands, and status to output during evaluation
#          2 = As in dbg_lvl=1, but DO NOT EXECUTE COMMANDS (i.e., pretend to run but do not regrid anything)
#          3 = As in dbg_lvl=1, and pass debug level through to NCO/ncks

# Set NCO version and directory
nco_exe=`which ncks`
if [ -z "${nco_exe}" ]; then
    echo "ERROR: Unable to find NCO, nco_exe = ${nco_exe}"
    exit 1
fi # !nco_exe
# StackOverflow method finds NCO directory
while [ -h "${nco_exe}" ]; do
  drc_nco="$( cd -P "$( dirname "${nco_exe}" )" && pwd )"
  nco_exe="$(readlink "${nco_exe}")"
  [[ ${nco_exe} != /* ]] && nco_exe="${drc_nco}/${nco_exe}"
done
drc_nco="$( cd -P "$( dirname "${nco_exe}" )" && pwd )"
nco_vrs=$(ncks --version 2>&1 > /dev/null | grep NCO | awk '{print $5}')
nco_sng=$(ncks --version 2>&1 > /dev/null | grep NCO | awk -F '"' '{print $2}')
# 20190218: Die quickly when NCO is found yet cannot run, e.g., due to linker errors
if [ -z "${nco_vrs}" ]; then
    echo "${spt_nm}: ERROR ${nco_exe} dies with error message on next line:"
    $(ncks --version)
    if [ "${NCO_PATH_OVERRIDE}" != 'Yes' ]; then
	printf "HINT: Run-time errors due to link issues (e.g., libraries missing or not found) might be solved at supported national labs (ALCF, NCAR, NERSC, OLCF, PNNL) by employing NCO machine-dependent hardcoded paths/modules. To try this, re-run command after setting \"export NCO_PATH_OVERRIDE=Yes\".\n"
    fi # !NCO_PATH_OVERRIDE
    exit 1
fi # !nco_vrs
lbr_vrs=$(ncks --library 2>&1 > /dev/null | awk '{print $6}')

# Detect and warn about mixed modules (for Qi Tang 20170531)
if [ "${drc_spt}" != "${drc_nco}" ]; then
    echo "WARNING: Possible mixture of NCO versions from different locations. Script ${spt_nm} is from directory ${drc_spt} while NCO binaries are from directory ${drc_nco}. Normally the script and binaries are from the same executables directory. This WARNING may be safely ignored for customized scripts and/or binaries that the user has intentionally split into different directories."
    echo "HINT: Conflicting script and binary directories may result from 1) Hardcoding an NCO script and/or binary pathname, 2) Having incomplete NCO installations in one or more directories in the \$PATH environment variable, 3) Loading multiple NCO modules with different locations."
fi # drc_spt

# When running in a terminal window (not in an non-interactive batch queue)...
if [ -n "${TERM}" ]; then
    # Set fonts for legibility
    if [ -x /usr/bin/tput ] && tput setaf 1 &> /dev/null; then
	fnt_bld=`tput bold` # Bold
	fnt_nrm=`tput sgr0` # Normal
	fnt_rvr=`tput smso` # Reverse
	fnt_tlc=`tput sitm` # Italic
    else
	fnt_bld="\e[1m" # Bold
	fnt_nrm="\e[0m" # Normal
	fnt_rvr="\e[07m" # Reverse
	fnt_tlc="\e[3m" # Italic
    fi # !tput
fi # !TERM

# Pre-define enumerated types used in defaults
par_bck='background' # [sng] Parallelism: background
par_mpi='mpi' # [sng] Parallelism: MPI
par_srl='serial' # [sng] Parallelism: serial
vrb_0=0 # [enm] Verbosity level: Quiet
vrb_1=1 # [enm] Verbosity level: Standard, minimal file I/O
vrb_2=2 # [enm] Verbosity level: All file I/O
vrb_3=3 # [enm] Verbosity level: English
vrb_4=4 # [enm] Verbosity level: Pedantic

# Defaults for command-line options and some derived variables
# Modify these defaults to save typing later
a2o_flg='No' # [flg] Atmosphere-to-ocean (only used by Tempest mesh generator)
alg_typ='nco_con' # [sng] Algorithm for remapping (bilinear|conserve|conserve2nd|nearestdtos|neareststod|patch|tempest|se2fv_flx|se2fv_stt|se2fv_alt|se2se|fv2se_flx|fv2se_stt|fv2se_alt|fv2fv_flx|fv2fv_stt|nco_con|nco_nni)
att_flg='No' # [flg] Add/alter attributes (e.g., _FillValue) before regridding
bch_pbs='No' # [sng] PBS batch (non-interactive) job
bch_slr='No' # [sng] SLURM batch (non-interactive) job
chk_map='Yes' # [flg] Check map-file quality
cln_flg='Yes' # [flg] Clean-up (remove) intermediate files before exiting
clm_flg='No' # [flg] Invoked by ncclimo script
d2f_flg='No' # [flg] Convert double-precision fields to single-precision
d2f_opt='-M dbl_flt' # [sng] Option string to convert double-precision fields to single-precision
dbg_lvl=0 # [nbr] Debugging level
dfl_lvl='' # [enm] Deflate level
dpt_exe_mpas='add_depth.py' # [sng] Depth coordinate addition command for MPAS
dpt_flg='No' # [flg] Add depth coordinate to MPAS files
dpt_fl='' # [sng] Depth file with refBottomDepth for MPAS ocean
#drc_in="${drc_pwd}" # [sng] Input file directory
drc_in='' # [sng] Input file directory
drc_in_xmp='~/drc_in' # [sng] Input file directory for examples
drc_out="${drc_pwd}" # [sng] Output file directory
drc_out_xmp="~/rgr" # [sng] Output file directory for examples
dst_fl='' # [sng] Destination file
dst_xmp='dst.nc' # [sng] Destination file for examples
dt_sng=`date +%Y%m%d` # [sng] Date string for MWF map names
dvn_flg='Yes' # [flg] Send internal NCO regridder output to /dev/null
esmf_typ='' # [sng] ESMF extrapolation type (nearestidavg|neareststod|none)
fl_fmt='' # [enm] Output file format
fl_nbr=0 # [nbr] Number of files to remap
flg_grd_only='No' # [flg] Create grid then exit before regridding
flg_hrz='No' # [flg] Perform horizontal regridding
# 20200119 appending attribute containing remap_command causes ncatted to fail, temporarily remove it
#gaa_sng="--gaa remap_script=${spt_nm} --gaa remap_command=\"'${cmd_ln}'\" --gaa remap_hostname=${HOSTNAME} --gaa remap_version=${nco_vrs}" # [sng] Global attributes to add
gaa_sng="--gaa remap_script=${spt_nm} --gaa remap_hostname=${HOSTNAME} --gaa remap_version=${nco_vrs}" # [sng] Global attributes to add
gll_fl='' # [sng] GLL grid metadata (geometry+connectivity+Jacobian) file
grd_dst='' # [sng] Destination grid-file
grd_dst_xmp='grd_dst.nc' # [sng] Destination grid-file for examples
grd_sng='' # [sng] Grid string
grd_src='' # [sng] Source grid-file
grd_src_xmp='grd_src.nc' # [sng] Source grid-file for examples
grd_vrt_xmp='grd_vrt.nc' # [sng] Vertical grid-file for examples
hdr_pad='10000' # [B] Pad at end of header section
hnt_dst='' # [sng] ERWG hint for destination grid
hnt_src='' # [sng] ERWG hint for source grid
in_fl='' # [sng] Input file
in_xmp='in.nc' # [sng] Input file for examples
inp_aut='No' # [sng] Input file list automatically generated (in ncclimo, or specified with -i in ncremap)
inp_glb='No' # [sng] Input file list from globbing directory 
inp_psn='No' # [sng] Input file list from positional arguments
inp_std='No' # [sng] Input file list from stdin
job_nbr=2 # [nbr] Job simultaneity for parallelism
map_fl='' # [sng] Map-file
map_rsl_fl='' # [sng] File containing results of weight-generation command (i.e., map_fl or map_trn_fl for monotr)
map_trn_fl='' # [sng] Map-file transpose (for Tempest)
map_mk='No' # [flg] Generate map-file (i.e., map does not yet exist)
map_usr_flg='No' # [flg] User supplied argument to --map option
map_xmp='map.nc' # [sng] Map-file for examples
mbt_flg='No' # [flg] mbtempest front-end to TempestRemap
mlt_map_flg='Yes' # [sng] Multi-map flag
mpi_flg='No' # [sng] Parallelize over nodes
msh_fl='' # [sng] Mesh-file (for Tempest)
msk_dst='' # [sng] Mask-template variable in destination file
msk_out='' # [sng] Mask variable in regridded file
msk_src='' # [sng] Mask-template variable in source file
mss_val='-9.99999979021476795361e+33' # [frc] Missing value for MPAS (ocean+seaice)
#mss_val='-1.0e36' # [frc] Missing value for MPAS (landice)
nco_opt='--no_tmp_fl' # [sng] NCO options (e.g., '-6 -t 1')
nd_nbr=1 # [nbr] Number of nodes
np_se_nbr=4 # [nbr] Polynomial order for TempestRemap SE maps
out_fl='' # [sng] Output file
out_xmp='out.nc' # [sng] Output file for examples
par_typ="${par_bck}" # [sng] Parallelism type
pdq_opt='' # [sng] ncpdq dimension permutation option
ppc_prc='' # [nbr] Precision-preserving compression number of significant digits
prc_typ='' # [sng] Procedure type
prs_stt='' # [sng] Preserved statistic ('integral' or 'mean')
qea_flg='No' # [sng] Quasi-equal area mode for TempestRemap
rgr_opt='--rgr lat_nm_out=lat#lon_nm_out=lon' # [sng] Regridding options
#rgr_opt='--rgr lat_dnm_nm=x#lon_dmn_nm=y' # [sng] Regridding options for projection grid
rnr_thr='' # [frc] Renormalization option
sgs_frc='' # [sng] Sub-grid fraction variable
sgs_msk='' # [sng] Sub-grid mask variable
sgs_nrm='1.0' # [frc] Sub-grid normalization
skl_fl='' # [sng] Skeleton file
std_chk='Yes' # [sng] Check stdin for input file list
std_flg='No' # [sng] Input available from pipe to stdin
thr_nbr=2 # [nbr] Thread number for regridder
trn_map='No' # [flg] Tempest transpose map (i.e., fv2se_flx == monotr)
ugrid_fl='' # [sng] UGRID file
unq_sfx=".pid${spt_pid}" # [sng] Unique suffix
#var_lst='FSNT,AODVIS' # [sng] Variables to process (empty means all)
var_lst='' # [sng] Variables to process (empty means all)
var_rgr='' # [sng] CF template variable
var_xmp='FSNT' # [sng] Variable list for examples
vrb_lvl=${vrb_2} # [enm] Verbosity level
vrs_prn='No' # [sng] Print version information
vrt_fl='' # [sng] Vertical coordinate file
vrt_nm='' # [sng] Vertical coordinate name
vrt_opt='' # [sng] Vertical options (e.g., '--rgr xtr_mth=mss_val')
vrt_ntp='' # [sng] Vertical interpolation type (lin|log)
vrt_xtr='' # [sng] Vertical extrapolation type (mss_val|nrs_ngh)
wgt_exe_esmf='ESMF_RegridWeightGen' # [sng] ESMF executable
wgt_exe_mbt='mbtempest' # [sng] MOAB-Tempest executable
wgt_exe_nco='ncks' # [sng] NCO executable
wgt_exe_tps='GenerateOfflineMap' # [sng] TempestRemap executable
wgt_typ='esmf' # [sng] Weight-generator program ('esmf' or 'nco' or 'tempest')
wgt_opt='' # [sng] Weight-generator options
wgt_opt_esmf='--no_log --ignore_unmapped' # [sng] ESMF_RegridWeightGen weight-generation options (ESMF < 7.1.0r)
#wgt_opt_esmf='--ignore_unmapped --ignore_degenerate' # [sng] ESMF_RegridWeightGen weight-generation options (ESMF >= 7.1.0r) (ignore_degenerate is required for CICE regridding with ESMF >= 7.1.0r, and is not supported or required with ESMF < 7.1.0r)
wgt_opt_nco='-O --dmm_in_mk' # [sng] NCO weight-generation options
wgt_opt_tps='' # [sng] TempestRemap weight-generation options
msh_opt_tps='' # [sng] TempestRemap mesh-generation options
xcl_flg='No' # [sng] Exclude rather than extract variable list
xtn_var='' # [sng] Extensive variables (e.g., 'TSurfStd_ct')
xtr_nsp=8 # [nbr] Extrapolation number of source points (for ESMF & NCO only)
xtr_xpn=2.0 # [frc] Extrapolation exponent (absolute value) (for ESMF & NCO only)

# Set temporary-file directory (must be writable by user)
if [ -d "${TMPDIR}" ]; then
    # Fancy %/ syntax removes trailing slash (e.g., from $TMPDIR)
    drc_tmp="${TMPDIR%/}"
elif [ -d '/tmp' ]; then
    drc_tmp='/tmp'
else
    drc_tmp=${PWD}
fi # !gpfs

function fnc_usg_prn { # NB: dash supports fnc_nm (){} syntax, not function fnc_nm{} syntax
    # Print usage
    printf "${fnt_rvr}Basic usage:\n${fnt_nrm} ${fnt_bld}${spt_nm} -d dst_fl in_fl out_fl${fnt_nrm}\n"
    printf "${fnt_nrm} ${fnt_bld}${spt_nm} --destination=dst_fl --input_file=in_fl --output_file=out_fl${fnt_nrm}\n\n"
    echo "Command-line options [long-option synonyms in ${fnt_tlc}italics${fnt_nrm}]:"
    echo "${fnt_rvr}-3${fnt_nrm}          Output file format CLASSIC (netCDF3 classic CDF1) [${fnt_tlc}fl_fmt, file_format=classic${fnt_nrm}]"
    echo "${fnt_rvr}-4${fnt_nrm}          Output file format NETCDF4 (netCDF4 extended HDF5) [${fnt_tlc}fl_fmt, file_format=netcdf4${fnt_nrm}]"
    echo "${fnt_rvr}-5${fnt_nrm}          Output file format 64BIT_DATA (netCDF3/PnetCDF CDF5) [${fnt_tlc}fl_fmt, file_format=64bit_data${fnt_nrm}]"
    echo "${fnt_rvr}-6${fnt_nrm}          Output file format 64BIT_OFFSET (netCDF3 64bit CDF2) [${fnt_tlc}fl_fmt, file_format=64bit_offset${fnt_nrm}]"
    echo "${fnt_rvr}-7${fnt_nrm}          Output file format NETCDF4_CLASSIC (netCDF4 classic HDF5) [${fnt_tlc}fl_fmt, file_format=netcdf4_classic${fnt_nrm}]"
    echo "${fnt_rvr}-a${fnt_nrm} ${fnt_bld}alg_typ${fnt_nrm}  Algorithm for weight generation (default ${fnt_bld}${alg_typ}${fnt_nrm}) [${fnt_tlc}alg_typ, algorithm, regrid_algorithm${fnt_nrm}]"
    echo "            ESMF algorithms: bilinear|conserve|conserve2nd|nearestdtos|neareststod|patch"
    echo "            NCO algorithms: nco_con (1st order conservative algorithm similar to \"conserve\"), nco_nni (nearest-neighbor-weighted-interpolation/extrapolation)"
    echo "            Tempest algorithms: fv2fv|fv2fv_flx|fv2fv_stt|fv2se_flx|fv2se_stt|fv2se_alt|se2fv_flx|se2fv_stt|se2fv_alt|se2se|tempest"
    echo " ${fnt_bld}--a2o${fnt_nrm}      Atmosphere-to-ocean remap (for Tempest only) (default ${fnt_bld}${a2o_flg}${fnt_nrm}) [${fnt_tlc}a2o, atm2ocn, b2l, big2ltl, l2s, lrg2sml${fnt_nrm}]"
    echo "${fnt_rvr}-D${fnt_nrm} ${fnt_bld}dbg_lvl${fnt_nrm}  Debug level (default ${fnt_bld}${dbg_lvl}${fnt_nrm}) [${fnt_tlc}dbg_lvl, dbg, debug, debug_level${fnt_nrm}]"
    echo "${fnt_rvr}-d${fnt_nrm} ${fnt_bld}dst_fl${fnt_nrm}   Data file to infer destination grid from (empty means none, i.e., use grd_fl, grd_sng, or map_fl)) (default ${fnt_bld}${dst_fl}${fnt_nrm}) [${fnt_tlc}dst_fl, destination_file, tpl, tpl_fl, template, template_file${fnt_nrm}]"
    echo " ${fnt_bld}--d2f${fnt_nrm}      Convert double-precision fields to single-precision (default ${fnt_bld}${d2f_flg}${fnt_nrm}) [${fnt_tlc}d2f | d2s | dbl_flt | dbl_sgl | double_float${fnt_nrm}]"
    echo " ${fnt_bld}--devnull${fnt_nrm}  Send NCO weight-generator messages to /dev/null (default ${fnt_bld}${dvn_flg}${fnt_nrm}) [${fnt_tlc}devnull, dev_nll, dvn_flg${fnt_nrm}]"
    echo " ${fnt_bld}--dpt${fnt_nrm}      Add depth coordinate to MPAS files (default ${fnt_bld}${dpt_flg}${fnt_nrm}) [${fnt_tlc}dpt | depth | add_dpt | add_depth${fnt_nrm}]"
    echo " ${fnt_bld}--dpt_fl${fnt_nrm}   Depth file with refBottomDepth for MPAS ocean (empty means none) (default ${fnt_bld}${dpt_fl}${fnt_nrm}) [${fnt_tlc}dpt_fl, mpas_fl, mpas_depth, depth_file${fnt_nrm}]"
    echo " ${fnt_bld}--dt_sng${fnt_nrm}   Date string (for MWF map names) (default ${fnt_bld}${dt_sng}${fnt_nrm}) [${fnt_tlc}dt_sng, date_string${fnt_nrm}]"
    echo " ${fnt_bld}--esmf_typ${fnt_nrm} ESMF Extrapolation type (empty means none) (default ${fnt_bld}${esmf_typ}${fnt_nrm}) [${fnt_tlc}esmf_typ, esmf_mth, esmf_extrapolation_type, esmf_extrapolation_method${fnt_nrm}] (nearestidavg|neareststod|none)"
    echo " ${fnt_bld}--fl_fmt${fnt_nrm}   File format (empty is netCDF3 64bit CDF2) (default ${fnt_bld}${fl_fmt}${fnt_nrm}) [${fnt_tlc}fl_fmt, fmt_out, file_format, format_out${fnt_nrm}]"
    echo "${fnt_rvr}-G${fnt_nrm} ${fnt_bld}grd_sng${fnt_nrm}  Grid generation arguments (empty means none) (default ${fnt_bld}${grd_sng}${fnt_nrm}) [${fnt_tlc}grd_sng, grid_generation, grid_gen, grid_string${fnt_nrm}]"
    echo "${fnt_rvr}-g${fnt_nrm} ${fnt_bld}grd_dst${fnt_nrm}  Grid-file (destination) (empty means none, i.e., infer from dst_fl or use map_fl) (default ${fnt_bld}${grd_dst}${fnt_nrm}) [${fnt_tlc}grd_dst, grid_dest, dst_grd, dest_grid, destination_grid${fnt_nrm}]"
#    echo " ${fnt_bld}--gll_fl${fnt_nrm}   GLL metadata (SE grid geometry+connectivity+Jacobian) file (default ${fnt_bld}${gll_fl}${fnt_nrm}) [${fnt_tlc}gll_fl, gll_mtd, se_gmt, se_mtd${fnt_nrm}]" # Deprecate unused option
#    echo " ${fnt_bld}--hrd_pth${fnt_nrm}  Use hard-coded paths on known machines (e.g., cheyenne, cori) [${fnt_tlc}hrd_pth, hard_path, csz_exe, csz_bin_lib${fnt_nrm}]"
    echo "${fnt_rvr}-I${fnt_nrm} ${fnt_bld}drc_in${fnt_nrm}   Input directory (empty means none) (default ${fnt_bld}${drc_in}${fnt_nrm}) [${fnt_tlc}drc_in, in_drc, dir_in, in_dir, input${fnt_nrm}]"
    echo "${fnt_rvr}-i${fnt_nrm} ${fnt_bld}in_fl${fnt_nrm}    Input file (empty means pipe to stdin or drc_in) (default ${fnt_bld}${in_fl}${fnt_nrm}) [${fnt_tlc}in_fl, in_file, input_file${fnt_nrm}]"
    echo "${fnt_rvr}-j${fnt_nrm} ${fnt_bld}job_nbr${fnt_nrm}  Job simultaneity for parallelism (default ${fnt_bld}${job_nbr}${fnt_nrm}) [${fnt_tlc}job_nbr, job_number, jobs${fnt_nrm}]"
    echo "${fnt_rvr}-L${fnt_nrm} ${fnt_bld}dfl_lvl${fnt_nrm}  Deflate level (empty is none) (default ${fnt_bld}${dfl_lvl}${fnt_nrm}) [${fnt_tlc}dfl_lvl, dfl, deflate${fnt_nrm}]"
    echo "${fnt_rvr}-M${fnt_nrm}          Multi-map-file toggle (unset means generate one map-file per input file) [${fnt_tlc}mlt_map, no_multimap${fnt_nrm}]"
    echo "${fnt_rvr}-m${fnt_nrm} ${fnt_bld}map_fl${fnt_nrm}   Map-file (empty means generate internally) (default ${fnt_bld}${map_fl}${fnt_nrm}) [${fnt_tlc}map_fl, map, map_file, rgr_map, regrid_map${fnt_nrm}]"
    echo " ${fnt_bld}--mbt${fnt_nrm}      Use MOAB-Tempest (mbtempest) front-end to TempestRemap (default ${fnt_bld}${mbt_flg}${fnt_nrm}) [${fnt_tlc}mbt, mbtempest, moabtempest, tfe_mbt${fnt_nrm}]"
    echo " ${fnt_bld}--msh_fl${fnt_nrm}   Mesh-file for grid intersection (empty means generate internally or not at all) (default ${fnt_bld}${msh_fl}${fnt_nrm}) [${fnt_tlc}msh_fl, msh, mesh, mesh_file${fnt_nrm}]"
    echo " ${fnt_bld}--msk_dst${fnt_nrm}  Mask-template variable in destination file (empty means none) (default ${fnt_bld}${msk_dst}${fnt_nrm}) [${fnt_tlc}msk_dst, dst_msk, mask_destination, mask_dst${fnt_nrm}]"
    echo " ${fnt_bld}--msk_out${fnt_nrm}  Mask variable in regridded file (empty means none) (default ${fnt_bld}${msk_out}${fnt_nrm}) [${fnt_tlc}msk_out, out_msk, mask_output, mask_rgr${fnt_nrm}]"
    echo " ${fnt_bld}--msk_src${fnt_nrm}  Mask-template variable in source file (empty means none) (default ${fnt_bld}${msk_src}${fnt_nrm}) [${fnt_tlc}msk_src, src_msk, mask_source, mask_src${fnt_nrm}]"
    echo " ${fnt_bld}--mss_val${fnt_nrm}  Missing value for MPAS (empty means none) (default ${fnt_bld}${mss_val}${fnt_nrm}) [${fnt_tlc}mss_val, fll_val, missing_value, fill_value${fnt_nrm}]"
    echo "${fnt_rvr}-n${fnt_nrm} ${fnt_bld}nco_opt${fnt_nrm}  NCO options (empty means none) (default ${fnt_bld}${nco_opt}${fnt_nrm}) [${fnt_tlc}nco_opt, nco_options${fnt_nrm}]"
    echo " ${fnt_bld}--nm_dst${fnt_nrm}   Short name of destination grid (required for MWF, no default) [${fnt_tlc}nm_dst, name_dst, nm_sht_dst, short_name_destination${fnt_nrm}]"
    echo " ${fnt_bld}--nm_src${fnt_nrm}   Short name of source grid (required for MWF, no default) [${fnt_tlc}nm_src, name_src, nm_sht_src, short_name_source${fnt_nrm}]"
    echo " ${fnt_bld}--no_cll_msr${fnt_nrm}  Omit cell_measures variables (e.g., 'area') [${fnt_tlc}no_area, no_cll_msr, no_cell_measures${fnt_nrm}]"
    echo " ${fnt_bld}--no_frm_trm${fnt_nrm}  Omit formula_terms variables (e.g., 'hyba', 'PS') [${fnt_tlc}no_frm_trm, no_formula_terms${fnt_nrm}]"
    echo " ${fnt_bld}--no_stg_grd${fnt_nrm}  Omit staggered grid variables ('slat, slon, w_stag') [${fnt_tlc}no_stg_grd, no_stg, no_stagger, no_staggered_grid${fnt_nrm}]"
    echo " ${fnt_bld}--no_stdin${fnt_nrm} Do not check stdin for input file list [${fnt_tlc}no_stdin, no_inp_std, no_redirect, no_standard_input${fnt_nrm}]"
    echo "${fnt_rvr}-O${fnt_nrm} ${fnt_bld}drc_out${fnt_nrm}  Output directory (default ${fnt_bld}${drc_out}${fnt_nrm}) [${fnt_tlc}drc_out, out_drc, dir_out, out_dir, output${fnt_nrm}]"
    echo "${fnt_rvr}-o${fnt_nrm} ${fnt_bld}out_fl${fnt_nrm}   Output-file (regridded file) (empty copies Input filename) (default ${fnt_bld}${out_fl}${fnt_nrm}) [${fnt_tlc}out_fl, out_file, output_file${fnt_nrm}]"
    echo "${fnt_rvr}-P${fnt_nrm} ${fnt_bld}prc_typ${fnt_nrm}  Procedure type (empty means none) (default ${fnt_bld}${prc_typ}${fnt_nrm}) [${fnt_tlc}prc_typ, pdq_typ, prm_typ, procedure${fnt_nrm}]"
    echo "${fnt_rvr}-p${fnt_nrm} ${fnt_bld}par_typ${fnt_nrm}  Parallelism type (default ${fnt_bld}${par_typ}${fnt_nrm}) [${fnt_tlc}par_typ, par_md, parallel_type, parallel_mode, parallel${fnt_nrm}]"
# 20171101: Implement but do not yet advertise PPC in ncremap
# 20200618: Document and advertise PPC in ncremap
    echo " ${fnt_bld}--pdq_opt${fnt_nrm}  ncpdq dimension permutation string (empty means none) (default ${fnt_bld}${pdq_opt}${fnt_nrm}) [${fnt_tlc}pdq, pdq_opt, prm, prm_opt, permute${fnt_nrm}]"
    echo " ${fnt_bld}--ppc_prc${fnt_nrm}  Precision-preserving compression (empty means none) (default ${fnt_bld}${ppc_prc}${fnt_nrm}) [${fnt_tlc}ppc, ppc_prc, precision, quantize${fnt_nrm}]"
    echo " ${fnt_bld}--preserve${fnt_nrm} Preserved statistic (empty preserves integral, except mean for MPAS) (default ${fnt_bld}${prs_stt}${fnt_nrm}) [${fnt_tlc}preserve, prs_stt, preserved_statistic${fnt_nrm}]"
#    echo " ${fnt_bld}--qea_flg${fnt_nrm}  Quasi-equal area mode for TempestRemap (default ${fnt_bld}${qea_flg}${fnt_nrm}) [${fnt_tlc}qea, qea_flg, np2, quasi-equal-area${fnt_nrm}]"
    echo "${fnt_rvr}-R${fnt_nrm} ${fnt_bld}rgr_opt${fnt_nrm}  Regrid options (empty means none) (default ${fnt_bld}${rgr_opt}${fnt_nrm}) [${fnt_tlc}rgr_opt, regrid_options${fnt_nrm}]"
    echo "${fnt_rvr}-r${fnt_nrm} ${fnt_bld}rnr_thr${fnt_nrm}  Renormalization threshold (empty means none (except for MPAS, see documentation)) (default ${fnt_bld}${rnr_thr}${fnt_nrm}) [${fnt_tlc}rnr_thr, rnr, renormalize, renormalization_threshold${fnt_nrm}]"
    echo " ${fnt_bld}--rgn_dst${fnt_nrm}  Regional destination grid [${fnt_tlc}rgn_dst, dst_rgn, regional_destination${fnt_nrm}]"
    echo " ${fnt_bld}--rgn_src${fnt_nrm}  Regional source grid [${fnt_tlc}rgn_src, src_rgn, regional_source${fnt_nrm}]"
    echo " ${fnt_bld}--rrg_bb_wesn${fnt_nrm}  Regional regridding bounding-box WESN order (empty means none) (default ${fnt_bld}${bb_wesn}${fnt_nrm}) [${fnt_tlc}rrg_bb_wesn, bb, bb_wesn, wesn_sng${fnt_nrm}]"
    echo " ${fnt_bld}--rrg_dat_glb${fnt_nrm}  Regional regridding global data file (empty means none) (default ${fnt_bld}${dat_glb}${fnt_nrm}) [${fnt_tlc}rrg_dat_glb, dat_glb, data_global, global_data${fnt_nrm}]"
    echo " ${fnt_bld}--rrg_grd_glb${fnt_nrm}  Regional regridding global grid file (empty means none) (default ${fnt_bld}${grd_glb}${fnt_nrm}) [${fnt_tlc}rrg_grd_glb, grd_glb, grid_global, global_grid${fnt_nrm}]"
    echo " ${fnt_bld}--rrg_grd_rgn${fnt_nrm}  Regional regridding regional grid file (empty means none) (default ${fnt_bld}${grd_rgn}${fnt_nrm}) [${fnt_tlc}rrg_grd_rgn, grd_rgn, grid_regional, regional_grid${fnt_nrm}]"
    echo " ${fnt_bld}--rrg_rnm_sng${fnt_nrm}  Regional regridding rename string (empty means none) (default ${fnt_bld}${rnm_sng}${fnt_nrm}) [${fnt_tlc}rrg_rnm_sng, rnm_sng, rename_string${fnt_nrm}]"
    echo "${fnt_rvr}-s${fnt_nrm} ${fnt_bld}grd_src${fnt_nrm}  Grid-file (source) (empty means infer or use map_fl) (default ${fnt_bld}${grd_src}${fnt_nrm}) [${fnt_tlc}grd_src, grid_source, source_grid, src_grd${fnt_nrm}]"
    echo " ${fnt_bld}--sgs_frc${fnt_nrm}  Sub-grid fraction variable (empty means none) (default ${fnt_bld}${sgs_frc}${fnt_nrm}) [${fnt_tlc}sgs_frc, ice_frc, lnd_frc, ocn_frc, subgrid_fraction${fnt_nrm}]"
    echo " ${fnt_bld}--sgs_msk${fnt_nrm}  Sub-grid mask variable (empty means none) (default ${fnt_bld}${sgs_msk}${fnt_nrm}) [${fnt_tlc}sgs_msk, ice_msk, lnd_msk, ocn_msk, subgrid_mask${fnt_nrm}]"
    echo " ${fnt_bld}--sgs_nrm${fnt_nrm}  Sub-grid fraction normalization (empty means none) (default ${fnt_bld}${sgs_nrm}${fnt_nrm}) [${fnt_tlc}sgs_nrm, subgrid_normalization${fnt_nrm}]"
    echo " ${fnt_bld}--skl_fl${fnt_nrm}   Skeleton file (empty means none) (default ${fnt_bld}${skl_fl}${fnt_nrm}) [${fnt_tlc}skl_fl, skl, skeleton, skeleton_file${fnt_nrm}]"
    echo " ${fnt_bld}--std_flg${fnt_nrm}  Stdin used for input (default ${fnt_bld}${inp_std}${fnt_nrm}) [${fnt_tlc}stdin, std_flg, inp_std, redirect, standard_input${fnt_nrm}]"
    echo "${fnt_rvr}-T${fnt_nrm} ${fnt_bld}drc_tmp${fnt_nrm}  Temporary directory (for intermediate files) (default ${fnt_bld}${drc_tmp}${fnt_nrm}) [${fnt_tlc}drc_tmp, tmp_drc, dir_tmp, tmp_dir, tmp${fnt_nrm}]"
    echo "${fnt_rvr}-t${fnt_nrm} ${fnt_bld}thr_nbr${fnt_nrm}  Thread number for regridder (default ${fnt_bld}${thr_nbr}${fnt_nrm}) [${fnt_tlc}thr_nbr, thr, thread_number, thread, threads${fnt_nrm}]"
    echo "${fnt_rvr}-U${fnt_nrm}          Unpack input prior to regridding [${fnt_tlc}unpack, upk, upk_inp${fnt_nrm}]"
    echo "${fnt_rvr}-u${fnt_nrm} ${fnt_bld}unq_sfx${fnt_nrm}  Unique suffix (prevents intermediate files from sharing names) (default ${fnt_bld}${unq_sfx}${fnt_nrm}) [${fnt_tlc}unq_sfx, unique_suffix, suffix${fnt_nrm}]"
    echo " ${fnt_bld}--ugrid_fl${fnt_nrm} UGRID file (empty means none) (default ${fnt_bld}${ugrid_fl}${fnt_nrm}) [${fnt_tlc}ugrid_fl, ugrid, ugrid_file${fnt_nrm}]"
    echo " ${fnt_bld}--uio${fnt_nrm}      Unbuffered I/O (NC_SHARE) for netCDF3 files [${fnt_tlc}uio, unbuffered, share${fnt_nrm}]"
    echo "${fnt_rvr}-V${fnt_nrm} ${fnt_bld}var_rgr${fnt_nrm}  CF template variable (empty means none) (default ${fnt_bld}${var_rgr}${fnt_nrm}) [${fnt_tlc}var_rgr, rgr_var, var_cf, cf_var, cf_variable${fnt_nrm}]"
    echo "${fnt_rvr}-v${fnt_nrm} ${fnt_bld}var_lst${fnt_nrm}  Variable list (empty means all) (default ${fnt_bld}${var_lst}${fnt_nrm}) [${fnt_tlc}var_lst, variable_list, var, vars, variable, variables${fnt_nrm}]"
    echo " ${fnt_bld}--version${fnt_nrm}  Version and configuration information [${fnt_tlc}version, vrs, config, configuration, cnf${fnt_nrm}]"
    echo " ${fnt_bld}--vrb_lvl${fnt_nrm}  Verbosity level (default ${fnt_bld}${vrb_lvl}${fnt_nrm}) [${fnt_tlc}vrb_lvl, vrb, verbosity, print_verbosity${fnt_nrm}]"
    echo " ${fnt_bld}--vrt_fl${fnt_nrm}   Vertical coordinate file (empty means none) (default ${fnt_bld}${vrt_fl}${fnt_nrm}) [${fnt_tlc}vrt_fl, vrt, vrt_crd, vertical_coordinate${fnt_nrm}]"
    echo " ${fnt_bld}--vrt_nm${fnt_nrm}   Vertical coordinate name (empty means \"plev\") (default ${fnt_bld}${vrt_nm}${fnt_nrm}) [${fnt_tlc}vrt_nm, plev_nm, vertical_coordinate_name${fnt_nrm}]"
    echo " ${fnt_bld}--vrt_ntp${fnt_nrm}  Vertical interpolation type (empty means none) (default ${fnt_bld}${vrt_ntp}${fnt_nrm}) [${fnt_tlc}vrt_ntp, ntp_mth, interpolation_type, interpolation_method${fnt_nrm}] (lin|log)"
    echo " ${fnt_bld}--vrt_xtr${fnt_nrm}  Vertical extrapolation type (empty means none) (default ${fnt_bld}${vrt_xtr}${fnt_nrm}) [${fnt_tlc}vrt_xtr, xtr_mth, extrapolation_type, extrapolation_method${fnt_nrm}] (mss_val|nrs_ngh)"
    echo "${fnt_rvr}-W${fnt_nrm} ${fnt_bld}wgt_opt${fnt_nrm}  Weight-generator options (default ${fnt_bld}${wgt_opt_esmf}${fnt_nrm}) [${fnt_tlc}wgt_opt, esmf_opt, esmf_options, tempest_opt, tps_opt${fnt_nrm}]"
    echo "${fnt_rvr}-w${fnt_nrm} ${fnt_bld}wgt_cmd${fnt_nrm}  Weight-generator command (default ${fnt_bld}${wgt_exe_esmf}${fnt_nrm}) [${fnt_tlc}wgt_cmd, wgt_gnr, weight_command, weight_generator${fnt_nrm}]"
    echo "${fnt_rvr}-x${fnt_nrm} ${fnt_bld}xtn_var${fnt_nrm}  Extensive variables (empty means none) (default ${fnt_bld}${xtn_var}${fnt_nrm}) [${fnt_tlc}xtn_var, xtn_lst, extensive, var_xtn, extensive_variables${fnt_nrm}]"
    echo " ${fnt_bld}--xcl_var${fnt_nrm}  Exclude rather than extract var_lst [${fnt_tlc}xcl_var, xcl, exclude, exclude_variables${fnt_nrm}]"
    echo " ${fnt_bld}--xtr_nsp${fnt_nrm}  Extrapolation number of source points (for ESMF & NCO only) (default ${fnt_bld}${xtr_nsp}${fnt_nrm}) [${fnt_tlc}xtr_nsp, xtr_pnt_src_nbr, extrap_num_src_pnts${fnt_nrm}]"
    echo " ${fnt_bld}--xtr_xpn${fnt_nrm}  Extrapolation distance exponent (for ESMF & NCO only) (default ${fnt_bld}${xtr_xpn}${fnt_nrm}) [${fnt_tlc}xtr_xpn, xtr_dst_xpn, extrap_dist_exponent${fnt_nrm}]"
    printf "\n"
    printf "Examples: ${fnt_bld}$spt_nm -m ${map_xmp} ${in_xmp} ${out_xmp} ${fnt_nrm}\n"
    printf "          ${fnt_bld}$spt_nm -d ${dst_xmp} ${in_xmp} ${out_xmp} ${fnt_nrm}\n"
    printf "          ${fnt_bld}$spt_nm -g ${grd_dst_xmp} ${in_xmp} ${out_xmp} ${fnt_nrm}\n"
    printf "          ${fnt_bld}$spt_nm -s ${grd_src_xmp} -g ${grd_dst_xmp} -m ${map_xmp} ${fnt_nrm}\n"
    printf "          ${fnt_bld}$spt_nm -a aave  -d ${dst_xmp} ${in_xmp} ${out_xmp} ${fnt_nrm}\n"
    printf "          ${fnt_bld}$spt_nm -a bilin -d ${dst_xmp} ${in_xmp} ${out_xmp} ${fnt_nrm}\n"
    printf "          ${fnt_bld}$spt_nm -a fv2fv -d ${dst_xmp} ${in_xmp} ${out_xmp} ${fnt_nrm}\n"
    printf "          ${fnt_bld}$spt_nm -a nco   -d ${dst_xmp} ${in_xmp} ${out_xmp} ${fnt_nrm}\n"
    printf "          ${fnt_bld}$spt_nm -v ${var_xmp} -m ${map_xmp} ${in_xmp} ${out_xmp} ${fnt_nrm}\n"
    printf "          ${fnt_bld}$spt_nm -m ${map_xmp} -I ${drc_in_xmp} -O ${drc_out_xmp} ${fnt_nrm}\n"
    printf "          ${fnt_bld}$spt_nm -M -d ${dst_xmp} -I ${drc_in_xmp} -O ${drc_out_xmp} ${fnt_nrm}\n"
    printf "          ${fnt_bld}$spt_nm -M -g ${grd_dst_xmp} -I ${drc_in_xmp} -O ${drc_out_xmp} ${fnt_nrm}\n"
    printf "          ${fnt_bld}$spt_nm -s ${grd_src_xmp} -d ${dst_xmp} -I ${drc_in_xmp} -O ${drc_out_xmp} ${fnt_nrm}\n"
    printf "          ${fnt_bld}$spt_nm -d ${dst_xmp} -I ${drc_in_xmp} -O ${drc_out_xmp} ${fnt_nrm}\n"
    printf "          ${fnt_bld}$spt_nm -g ${grd_dst_xmp} -I ${drc_in_xmp} -O ${drc_out_xmp} ${fnt_nrm}\n"
    printf "          ${fnt_bld}$spt_nm --vrt=${grd_vrt_xmp} ${in_xmp} ${out_xmp} ${fnt_nrm}\n"
    printf "          ${fnt_bld}$spt_nm --vrt=${grd_vrt_xmp} -m ${map_xmp} ${in_xmp} ${out_xmp} ${fnt_nrm}\n"
    printf "          ${fnt_bld}ls mdl*2005*nc | $spt_nm -m ${map_xmp} -O ${drc_out_xmp} ${fnt_nrm}\n"
    printf "          ${fnt_bld}ls mdl*2005*nc | $spt_nm -d ${dst_xmp} -O ${drc_out_xmp} ${fnt_nrm}\n"
    printf "\nComplete documentation at http://nco.sf.net/nco.html#${spt_nm}\n\n"
    exit 1
} # end fnc_usg_prn()

# RRG processing needs NCO filters documented in http://nco.sf.net/nco.html#filter
function ncvarlst { ncks --trd -m ${1} | grep -E ': type' | cut -f 1 -d ' ' | sed 's/://' | sort ; }
function ncdmnlst { ncks --cdl -m ${1} | cut -d ':' -f 1 | cut -d '=' -s -f 1 ; }

function dst_is_grd {
    # Purpose: Is destination grid specified as SCRIP grid-file?
    # fxm: Not working yet
    # Figure-out whether data-file or grid-file and proceed accordingly
    # Allow ncremap to combine -d and -g switches
    # Usage: dst_is_grd ${fl}
    fl=${1}
    flg='Yes'
    #flg='No'
} # end dst_is_grd()

# Check argument number and complain accordingly
arg_nbr=$#
if [ ${arg_nbr} -eq 0 ]; then
  fnc_usg_prn
fi # !arg_nbr

# Parse command-line options:
# http://stackoverflow.com/questions/402377/using-getopts-in-bash-shell-script-to-get-long-and-short-command-line-options
# http://tuxtweaks.com/2014/05/bash-getopts
while getopts :34567a:CD:d:f:g:G:h:I:i:j:L:Mm:n:O:o:P:p:R:r:s:T:t:Uu:V:v:W:w:x:-: OPT; do
    case ${OPT} in
	3) fl_fmt='3' ;; # File format
	4) fl_fmt='4' ;; # File format
	5) fl_fmt='5' ;; # File format
	6) fl_fmt='6' ;; # File format
	7) fl_fmt='7' ;; # File format
	a) alg_typ="${OPTARG}" ;; # Algorithm
	C) clm_flg='Yes' ;; # Climo flag (undocumented)
	D) dbg_lvl="${OPTARG}" ;; # Debugging level
	d) dst_fl="${OPTARG}" ;; # Destination file
	g) grd_dst="${OPTARG}" ;; # Destination grid-file
	G) grd_sng="${OPTARG}" ;; # Grid generation string
	I) drc_in="${OPTARG}" ;; # Input directory
	i) in_fl="${OPTARG}" ;; # Input file
	j) job_usr="${OPTARG}" ;; # Job simultaneity
	L) dfl_lvl="${OPTARG}" ;; # Deflate level
	M) mlt_map_flg='No' ;; # Multi-map flag
	m) map_fl="${OPTARG}" ;; # Map-file
	n) nco_opt="${OPTARG} ${nco_opt}" ;; # NCO options
	O) drc_usr="${OPTARG}" ;; # Output directory
	o) out_fl="${OPTARG}" ;; # Output file
	P) prc_typ="${OPTARG}" ;; # Procedure type
	p) par_typ="${OPTARG}" ;; # Parallelism type
	r) rnr_thr="${OPTARG}" ;; # Renormalization threshold
	R) rgr_opt="${OPTARG}" ;; # Regridding options
	s) grd_src="${OPTARG}" ;; # Source grid-file
	T) tmp_usr="${OPTARG}" ;; # Temporary directory
	t) thr_usr="${OPTARG}" ;; # Thread number
	U) pdq_opt='-U' ;;        # Unpack input
	u) unq_usr="${OPTARG}" ;; # Unique suffix
	V) var_rgr="${OPTARG}" ;; # CF template variable 
	v) var_lst="${OPTARG}" ;; # Variables
	W) wgt_opt_usr="${OPTARG}" ;; # Weight-generator options
	w) wgt_usr="${OPTARG}" ;; # Weight-generator command
	x) xtn_var="${OPTARG}" ;; # Extensive variables
	-) LONG_OPTARG="${OPTARG#*=}"
	   case ${OPTARG} in
	       # Hereafter ${OPTARG} is long argument key, and ${LONG_OPTARG}, if any, is long argument value
	       # Long options with no argument, no short option counterpart
	       # Long options with argument, no short option counterpart
	       # Long options with short counterparts, ordered by short option key
	       a2o | atm2ocn | b2l | big2ltl | l2s | lrg2sml ) a2o_flg='Yes' ;; # # Atmosphere-to-ocean
	       a2o=?* | atm2ocn=?* | b2l=?* | big2ltl=?* | l2s=?* | lrg2sml=?* ) echo "No argument allowed for --${OPTARG switch}" >&2; exit 1 ;; # # Atmosphere-to-ocean
	       alg_typ=?* | algorithm=?* | regrid_algorithm=?* ) alg_typ="${LONG_OPTARG}" ;; # -a # Algorithm
	       clm_flg | climatology_flag ) clm_flg='Yes' ;; # -C # Climo flag (undocumented)
	       clm_flg=?* | climatology_flag=?* ) echo "No argument allowed for --${OPTARG switch}" >&2; exit 1 ;; # # clm_flg
	       d2f | d2s | dbl_flt | dbl_sgl | double_float ) d2f_flg='Yes' ;; # # Convert double-precision fields to single-precision
	       d2f=?* | d2s=?* | dbl_flt=?* | dbl_sgl=?* | double_float=?* ) echo "No argument allowed for --${OPTARG switch}" >&2; exit 1 ;; # # D2F
	       dbg_lvl=?* | dbg=?* | debug=?* | debug_level=?* ) dbg_lvl="${LONG_OPTARG}" ;; # -d # Debugging level
	       devnull=?* | dev_nll=?* | dev_null=?* | dvn_flg=?* ) dvn_flg="${LONG_OPTARG}" ;; # # Send NCO weight-generator messages to /dev/null
	       dfl_lvl=?* | deflate=?* | dfl=?* ) dfl_lvl="${LONG_OPTARG}" ;; # -L # Deflate level
	       dpt | depth | add_dpt | add_depth ) dpt_flg='Yes' ;; # # Add depth coordinate to MPAS files
	       dpt=?* | depth=?* | add_dpt=?* | add_depth=?* ) echo "No argument allowed for --${OPTARG switch}" >&2; exit 1 ;; # # DPT
	       dpt_fl=?* | mpas_fl=?* | mpas_file=?* | depth_file=?* ) dpt_fl="${LONG_OPTARG}" ;; # # Depth file with refBottomDepth for MPAS ocean
	       dst_fl=?* | destination_file=?* | tpl=?* | tpl_fl=?* | template=?* | template_file=?* ) dst_fl="${LONG_OPTARG}" ;; # -d # Destination file
	       grd_dst=?* | grid_dest=?* | dst_grd=?* | dest_grid=?* | destination_grid=?* ) grd_dst="${LONG_OPTARG}" ;; # -g # Destination grid-file
	       grd_sng=?* | grid_generation=?* | grid_gen=?* | grid_string=?* ) grd_sng="${LONG_OPTARG}" ;; # -G # Grid generation string
	       drc_in=?* | in_drc=?* | dir_in=?* | in_dir=?* | input=?* ) drc_in="${LONG_OPTARG}" ;; # -i # Input directory
	       dt_sng=?* | date_string=?* ) dt_sng="${LONG_OPTARG}" ;; # # Date string for MWF map names
	       esmf_typ=?* | esmf_mth=?* | esmf_extrap_type=?* | esmf_extrap_method=?* ) esmf_typ="${LONG_OPTARG}" ;; # # ESMF extrapolation type (nearestidavg|neareststod|none)
	       fl_fmt=?* | fmt_out=?* | file_format=?* | format_out=?* ) fl_fmt="${LONG_OPTARG}" ;; # # Output file format
	       gll_fl=?* | gll_mtd=?* | se_gmt=?* | se_mtd=?* ) gll_fl="${LONG_OPTARG}" ;; # # GLL grid metadata (geometry+connectivity+Jacobian) file
	       hrd_pth=?* | hard_path=?* | csz_exe=?* | csz_bin_lib=?* ) echo "No argument allowed for --${OPTARG switch}" >&2; exit 1 ;; # # Use hard-coded paths on known machines
	       in_fl=?* | in_file=?* | input_file=?* ) in_fl="${LONG_OPTARG}" ;; # -i # Input file
	       job_nbr=?* | job_number=?* | jobs=?* ) job_usr="${LONG_OPTARG}" ;; # -j # Job simultaneity
	       map_fl=?* | map=?* | map_file=?* | rgr_map=?* | regrid_map=?* ) map_fl="${LONG_OPTARG}" ;; # -m # Map-file
	       mbt | mbtempest | moabtempest | tfe_mbt ) mbt_flg='Yes' ;; # # mbtempest front-end to TempestRemap
	       mbt=?* | mbtempest=?* | moabtempest=?* | tfe_mbt=?* ) echo "No argument allowed for --${OPTARG switch}" >&2; exit 1 ;; # # mbtempest front-end to TempestRemap
	       mlt_map | multimap | no_multimap | nomultimap ) mlt_map_flg='No' ;; # -M # Multi-map flag
	       mlt_map=?* | multimap=?* | no_multimap=?* | nomultimap=?* ) echo "No argument allowed for --${OPTARG switch}" >&2; exit 1 ;; # -M # Multi-map flag
	       msh_fl=?* | msh=?* | mesh=?* | mesh_file=?* ) msh_fl="${LONG_OPTARG}" ;; # # Mesh file
	       msk_dst=?* | dst_msk=?* | mask_destination=?* | mask_dst=?* ) msk_dst="${LONG_OPTARG}" ;; # # Mask-template variable in destination file
	       msk_out=?* | out_msk=?* | mask_output=?* | mask_out=?* ) msk_out="${LONG_OPTARG}" ;; # # Mask variable in regridded file
	       msk_src=?* | src_msk=?* | mask_source=?* | mask_src=?* ) msk_src="${LONG_OPTARG}" ;; # # Mask-template variable in source file
	       mss_val=?* | fll_val=?* | missing_value=?* | fill_value=?* ) mss_val_usr="${LONG_OPTARG}" ;; # # Missing value for MPAS
	       nco_opt=?* | nco=?* | nco_options=?* ) nco_opt="${LONG_OPTARG} ${nco_opt}" ;; # -n # NCO options
	       nm_dst=?* | name_dst=?* | nm_sht_dst=?* | short_name_destination=?* ) nm_dst="${LONG_OPTARG}" ;; # # Short name of destination grid
	       nm_src=?* | name_src=?* | nm_sht_src=?* | short_name_source=?* ) nm_src="${LONG_OPTARG}" ;; # # Short name of source grid
	       no_area | no_cll_msr | no_cell_measures ) no_cll_msr='Yes' ;; # # Omit cell_measures variables
	       no_area=?* | no_cell_msr=?* | no_cell_measures=?* ) echo "No argument allowed for --${OPTARG switch}" >&2; exit 1 ;; # # Omit cell_measures variables
	       no_frm_trm | no_frm | no_formula_terms ) no_frm_trm='Yes' ;; # # Omit formula_terms variables
	       no_frm_trm=?* | no_frm=?* | no_formula_terms=?* ) echo "No argument allowed for --${OPTARG switch}" >&2; exit 1 ;; # # Omit formula_terms variables
	       no_stg_grd | no_stg | no_stagger | no_staggered_grid ) no_stg_grd='Yes' ;; # # Omit staggered grid variables
	       no_stg_grd=?* | no_stg=?* | no_stagger=?* | no_staggered_grid ) echo "No argument allowed for --${OPTARG switch}" >&2; exit 1 ;; # # Omit staggered grid variables
	       drc_out=?* | out_drc=?* | dir_out=?* | out_dir=?* | output=?* ) drc_usr="${LONG_OPTARG}" ;; # -O # Output directory
	       out_fl=?* | output_file=?* | out_file=?* ) out_fl="${LONG_OPTARG}" ;; # -o # Output file
	       prc_typ=?* | pdq_typ=?* | prm_typ=?* | procedure=?* ) prc_typ="${LONG_OPTARG}" ;; # -P # Procedure type
	       par_typ=?* | par_md=?* | parallel_type=?* | parallel_mode=?* | parallel=?* ) par_typ="${LONG_OPTARG}" ;; # -p # Parallelism type
	       pdq=?* | pdq_opt=?* | prm=?* | prm_opt=?* | permute=?* ) pdq_opt="${LONG_OPTARG}" ;; # # ncpdq dimension permutation option
	       ppc=?* | ppc_prc=?* | precision=?* | quantize=?* ) ppc_prc="${LONG_OPTARG}" ;; # # Precision-preserving compression
	       prs_stt=?* | preserve=?* | preserved_statistic=?* ) prs_stt="${LONG_OPTARG}" ;; # # Preserved statistic
	       qea | qea_flg | np2 | quasi-equal-area ) qea_flg='Yes' ;; # # Quasi-equal area mode for TempestRemap
	       qea=?* | qea_flg=?* | np2=?* | quasi-equal-area=?* ) echo "No argument allowed for --${OPTARG switch}" >&2; exit 1 ;; # # Quasi-equal area mode for TempestRemap
	       rgr_opt=?* | regrid_options=?* ) rgr_opt="${LONG_OPTARG}" ;; # -R # Regridding options
	       rnr_thr=?* | thr_rnr=?* | rnr=?* | renormalize=?* | renormalization_threshold=?* ) rnr_thr="${LONG_OPTARG}" ;; # -r # Renormalization threshold
	       rgn_dst=?* | dst_rgn=?* | regional_destination=?* ) hnt_dst='--dst_regional' ;; # # Regional destination grid
	       rgn_dst=?* | dst_rgn=?* | regional_destination=?* ) echo "No argument allowed for --${OPTARG switch}" >&2; exit 1 ;; # # Regional destination grid
	       rgn_src=?* | src_rgn=?* | regional_source=?* ) hnt_src='--src_regional' ;; # # Regional source grid
	       rgn_src=?* | src_rgn=?* | regional_source=?* ) echo "No argument allowed for --${OPTARG switch}" >&2; exit 1 ;; # # Regional source grid
	       rrg_bb_wesn=?* | bb_wesn=?* | bb=?* | bounding_box=?* ) bb_wesn="${LONG_OPTARG}" ; prc_typ='rrg' ; ;; # # Regional regridding bounding-box WESN order
	       rrg_dat_glb=?* | dat_glb=?* | data_global=?* | global_data=?* ) dat_glb="${LONG_OPTARG}" ; prc_typ='rrg' ; ;; # # Regional regridding global data file
	       rrg_grd_glb=?* | grd_glb=?* | grid_global=?* | global_grid=?* ) grd_glb="${LONG_OPTARG}" ; prc_typ='rrg' ; ;; # # Regional regridding global grid file
	       rrg_grd_rgn=?* | grd_rgn=?* | grid_regional=?* | regional_grid=?* ) grd_rgn="${LONG_OPTARG}" ; prc_typ='rrg' ; ;; # # Regional regridding regional grid file
	       rrg_rnm_sng=?* | rnm_sng=?* | rename_string=?* ) rnm_sng="${LONG_OPTARG}" ; prc_typ='rrg' ; ;; # # Regional regridding rename string
	       grd_src=?* | grid_source=?* | source_grid=?* | src_grd=?* ) grd_src="${LONG_OPTARG}" ;; # -s # Source grid-file
	       sgs_frc=?* | ice_frc=?* | lnd_frc=?* | ocn_frc=?* | subgrid_fraction=?* ) sgs_frc="${LONG_OPTARG}" ;; # # Sub-grid fraction variable
	       sgs_msk=?* | ice_msk=?* | lnd_msk=?* | ocn_msk=?* | subgrid_mask=?* ) sgs_msk="${LONG_OPTARG}" ;; # # Sub-grid mask variable
	       sgs_nrm=?* | subgrid_normalization=?* ) sgs_nrm="${LONG_OPTARG}" ;; # # Sub-grid fraction normalization
	       skl_fl=?* | skl=?* | skeleton=?* | skeleton_file=?* ) skl_fl="${LONG_OPTARG}" ;; # # Skeleton file
	       stdin | inp_std | std_flg | redirect | standard_input ) inp_std='Yes' ;; # # Input file list from stdin
	       stdin=?* | inp_std=?* | std_flg=?* | redirect=?* | standard_input=?* ) echo "No argument allowed for --${OPTARG switch}" >&2; exit 1 ;; # # Input file list from stdin

	       no_stdin | no_inp_std | no_redirect | no_standard_input ) std_chk='No' ;; # # Check stdin for input file list
	       no_stdin=?* | no_inp_std=?* | no_redirect=?* | no_standard_input=?* ) echo "No argument allowed for --${OPTARG switch}" >&2; exit 1 ;; # # Check stdin for input file list

	       drc_tmp=?* | tmp_drc=?* | dir_tmp=?* | tmp_dir=?* | tmp=?* ) tmp_usr="${LONG_OPTARG}" ;; # -T # Temporary directory
	       thr_nbr=?* | thr=?* | thread_number=?* | thread=?* | threads=?* ) thr_usr="${LONG_OPTARG}" ;; # -t # Thread number
	       unpack=?* | upk=?* | upk_inp=?* ) pdq_opt='-U' ;; # -U # Unpack input
	       unpack=?* | upk=?* | upk_inp=?* ) echo "No argument allowed for --${OPTARG switch}" >&2; exit 1 ;; # -U # Unpack input
	       ugrid_fl=?* | ugrid=?* | ugrid_file=?* ) ugrid_fl="${LONG_OPTARG}" ;; # # UGRID file
	       uio | unbuffered | share ) uio_flg='Yes' ;; # # Unbuffered I/O (NC_SHARE) for netCDF3 files
	       uio=?* | unbuffered=?* | share=?* ) echo "No argument allowed for --${OPTARG switch}" >&2; exit 1 ;; # # Unbuffered I/O (NC_SHARE) for netCDF3 files
	       unq_sfx=?* | unique_suffix=?* | suffix=?* ) unq_usr="${LONG_OPTARG}" ;; # -u # Unique suffix
	       var_rgr=?* | rgr_var=?* | var_cf=?* | cf_var=?* | cf_variable=?* ) var_rgr="${LONG_OPTARG}" ;; # -V # CF template variable 
	       var_lst=?* | variable_list=?* | var=?* | vars=?* | variable=?* | variables=?* ) var_lst="${LONG_OPTARG}" ;; # -v # Variables
	       version | vrs | config | configuration | cnf ) vrs_prn='Yes' ;; # # Print version information
	       version=?* | vrs=?* | config=?* | configuration=?* | cnf=?* ) echo "No argument allowed for --${OPTARG switch}" >&2; exit 1 ;; # # Print version information
	       vrb_lvl=?* | vrb=?* | verbosity=?* | print_verbosity=?* ) vrb_lvl="${LONG_OPTARG}" ;; # # Print verbosity
	       vrt_fl=?* | vrt=?* | vrt_crd=?* | vertical_coordinate=?* ) vrt_fl="${LONG_OPTARG}" ;; # # Vertical coordinate file
	       vrt_nm=?* | plev_nm=?* | vertical_coordinate_name=?* ) vrt_nm="${LONG_OPTARG}" ;; # # Vertical coordinate name
	       vrt_ntp=?* | ntp_mth=?* | interpolation_type=?* | interpolation_method=?* ) vrt_ntp="${LONG_OPTARG}" ;; # # Vertical interpolation type (lin|log)
	       vrt_xtr=?* | xtr_mth=?* | extrapolation_type=?* | extrapolation_method=?* ) vrt_xtr="${LONG_OPTARG}" ;; # # Vertical extrapolation type (mss_val|nrs_ngh)
	       wgt_opt=?* | esmf_opt=?* | esmf_options=?* | tps_opt=?* | tempest_opt=?* | tempest_options=?* ) wgt_opt_usr="${LONG_OPTARG}" ;; # -W # Weight-generator options
	       wgt_cmd=?* | weight_command=?* | wgt_gnr=?* | weight_generator=?* ) wgt_usr="${LONG_OPTARG}" ;; # -w # Weight-generator command
	       xcl_var | xcl | exclude | exclude_variables ) xcl_flg='Yes' ;; # # Exclude rather than extract variable list
	       xcl_var=?* | xcl=?* | exclude=?* | exclude_variables=?* ) echo "No argument allowed for --${OPTARG switch}" >&2; exit 1 ;; # # Exclude rather than extract variable list
	       xtn_var=?* | extensive=?* | var_xtn=?* | extensive_variables=?* ) xtn_var="${LONG_OPTARG}" ;; # -x # Extensive variables
	       xtr_nsp=?* | xtr_pnt_src_nbr=?* | extrap_num_src_pts=?* ) xtr_nsp_usr="${LONG_OPTARG}" ;; # # Extrapolation number of source points (for ESMF & NCO only)
	       xtr_xpn=?* | xtr_dst_xpn=?* | extrap_dist_exponent=?* ) xtr_xpn_usr="${LONG_OPTARG}" ;; # # Extrapolation exponent (for ESMF & NCO only)
               '' ) break ;; # "--" terminates argument processing
               * ) printf "\nERROR: Unrecognized option ${fnt_bld}--${OPTARG}${fnt_nrm}\n" >&2; fnc_usg_prn ;;
	   esac ;; # !OPTARG
	\?) # Unrecognized option
	    printf "\nERROR: Option ${fnt_bld}-${OPTARG}${fnt_nrm} not recognized\n" >&2
	    fnc_usg_prn ;;
    esac # !OPT
done # !getopts
shift $((OPTIND-1)) # Advance one argument
psn_nbr=$#
if [ ${psn_nbr} -ge 1 ]; then
    inp_psn='Yes'
    # 20200430 Input files on command-line mean we need not check standard-input
    std_chk='No'
fi # !psn_nbr
if [ "${d2f_flg}" != 'Yes' ]; then
    d2f_opt=''
fi # !d2f_flg

cmd_wgt_esmf=`command -v ${wgt_exe_esmf} --no_log 2> /dev/null`
if [ "$?" -eq 0 ]; then
    # 20180830 Add --ignore_degenerate to default ERWG options for ESMF >= 7.1.0r
    # 20181114 Add --no_log so ERWG does not try to write logfile into current (possibly write-protected) directory 
    erwg_vrs_sng=`ESMF_RegridWeightGen --no_log --version | grep ESMF_VERSION_STRING | cut -f 2 -d ':'`
    # Remove whitespace, answer should be something like "7.1.0r" or "6.3.0rp1"
    erwg_vrs_sng="${erwg_vrs_sng#"${erwg_vrs_sng%%[![:space:]]*}"}"
    # Extract first character
    erwg_vrs_mjr="${erwg_vrs_sng:0:1}"
    if [ -z "${erwg_vrs_mjr}" ]; then
	# Version can fail when ERWG fails, e.g., due to dynamic link issues
	printf "${spt_nm}: WARNING ${wgt_exe_esmf} (ERWG) found though does not run as expected. Possible dynamic linking issue due, e.g., to LD_LIBRARY_PATH configuration. Unable to determine ERWG version. ERWG may not be needed so continuing anyway...\n"
	erwg_vrs_sng='ERWG_VERSION_NOT_FOUND'
	erwg_vrs_mjr=7
    elif [ "${erwg_vrs_mjr}" -ge 7 ]; then
	wgt_opt_esmf="${wgt_opt_esmf} --ignore_degenerate"
    fi # !erwg_vrs_mjr
fi # !err
cmd_wgt_mbt=`command -v ${wgt_exe_mbt} 2> /dev/null`
cmd_wgt_nco=`command -v ${wgt_exe_nco} 2> /dev/null`
cmd_wgt_tps=`command -v ${wgt_exe_tps} 2> /dev/null`
cmd_dpt_mpas=`command -v ${dpt_exe_mpas} --no_log 2> /dev/null`
if [ ${vrs_prn} = 'Yes' ]; then
    printf "${spt_nm}, the NCO regridder and grid, map, and weight-generator, version ${nco_vrs} \"${nco_sng}\"\n"
    printf "Copyright (C) 2016--present Charlie Zender\n"
    printf "This program is part of NCO, the netCDF Operators\n"
    printf "NCO is free software and comes with a BIG FAT KISS and ABSOLUTELY NO WARRANTY\n"
    printf "You may redistribute and/or modify NCO under the terms of the\n"
    printf "3-Clause BSD License with exceptions described in the LICENSE file\n"
    printf "BSD: https://opensource.org/licenses/BSD-3-Clause\n"
    printf "LICENSE: https://github.com/nco/nco/tree/master/LICENSE\n"
    printf "Config: ${spt_nm} script located in directory ${drc_spt}\n"
    printf "Config: NCO binaries located in directory ${drc_nco}, linked to netCDF library version ${lbr_vrs}\n"
    if [ "${hrd_pth_fnd}" = 'Yes' ]; then
	printf "Config: Employ NCO machine-dependent hardcoded paths/modules for ${HOSTNAME}. (If desired, turn-off NCO hardcoded paths with \"export NCO_PATH_OVERRIDE=No\").\n"
    else
	printf "Config: No hardcoded machine-dependent path/module overrides. (If desired, turn-on NCO hardcoded paths at supported national labs with \"export NCO_PATH_OVERRIDE=Yes\").\n"
    fi # !hrd_pth_fnd
    printf "Config: External (non-NCO) program availability:\n"
    if [ -n "${cmd_wgt_esmf}" ]; then
	printf "Config: ESMF weight-generation command ${wgt_exe_esmf} version ${erwg_vrs_sng} found as ${cmd_wgt_esmf}\n"
    else
	printf "Config: ESMF weight-generation command ${wgt_exe_esmf} not found\n"
    fi # !err
    if [ -n "${cmd_wgt_mbt}" ]; then
	printf "Config: MOAB-Tempest weight-generation command ${wgt_exe_mbt} found as ${cmd_wgt_mbt}\n"
    else
	printf "Config: MOAB-Tempest weight-generation command ${wgt_exe_mbt} not found\n"
    fi # !err
    if [ -n "${cmd_dpt_mpas}" ]; then
	printf "Config: MPAS depth coordinate addition command ${dpt_exe_mpas} found as ${cmd_dpt_mpas}\n"
    else
	printf "Config: MPAS depth coordinate addition command ${dpt_exe_mpas} not found\n"
    fi # !err
    if [ -n "${cmd_wgt_tps}" ]; then
	printf "Config: TempestRemap weight-generation command ${wgt_exe_tps} found as ${cmd_wgt_tps}\n"
    else
	printf "Config: TempestRemap weight-generation command ${wgt_exe_tps} not found\n"
    fi # !err
    exit 0
fi # !vrs_prn

# Detect input on pipe to stdin:
# http://stackoverflow.com/questions/2456750/detect-presence-of-stdin-contents-in-shell-script
# http://unix.stackexchange.com/questions/33049/check-if-pipe-is-empty-and-run-a-command-on-the-data-if-it-isnt
# 20170119 "if [ ! -t 0 ]" tests whether unit 0 (stdin) is connected to terminal, not whether pipe has data
# Non-interactive batch mode (e.g., qsub, sbatch) disconnects stdin from terminal and triggers false-positives with ! -t 0
# 20170123 "if [ -p foo ]" tests whether foo exists and is a pipe or named pipe
# Non-interactive batch mode (i.e., sbatch) behaves as desired for -p /dev/stdin on SLURM
# Non-interactive batch mode (e.g., qsub) always returns true for -p /dev/stdin on PBS, leads to FALSE POSITIVES!
# This is because PBS uses stdin to set the job name
# Hence -p /dev/stdin test works everywhere tested except PBS non-interactive batch environment
# Check stdin if user has not explicitly disallowed it with --no_stdin
if [ "${std_chk}" = 'Yes' ]; then
    if [ -n "${PBS_ENVIRONMENT}" ]; then
	if [ "${PBS_ENVIRONMENT}" = 'PBS_BATCH' ]; then
	    # PBS batch detection suggested by OLCF ticket CCS #338970 on 20170127
	    bch_pbs='Yes'
	fi # !PBS_ENVIRONMENT
    fi # !PBS
    if [ -n "${SLURM_JOBID}" ] && [ -z "${SLURM_PTY_PORT}" ]; then
	# SLURM batch detection suggested by NERSC ticket INC0096873 on 20170127
	bch_slr='Yes'
    fi # !SLURM
    if [ ${bch_pbs} = 'Yes' ] || [ ${bch_slr} = 'Yes' ]; then
	# Batch environment
	if [ ${bch_pbs} = 'Yes' ]; then
	    if [ ! -p /dev/stdin ]; then
		# PBS batch jobs cause -p to return true except for stdin redirection 
		# When -p returns true we do not know whether stdin pipe contains any input
		# User must explicitly indicate use of stdin pipes with --stdin option
		# Redirection in PBS batch jobs unambiguously causes -p to return false
		inp_std='Yes'
	    fi # !stdin
	fi # !bch_slr
	if [ ${bch_slr} = 'Yes' ]; then
	    if [ -p /dev/stdin ]; then
		# SLURM batch jobs cause -p to return true for stdin pipes
		# When -p returns false we do not know whether output was redirectd
		# User must explicitly indicate use of redirection with --stdin option
		# Stdin pipes in SLURM batch jobs unambiguously cause -p to return true
		inp_std='Yes'
	    fi # !stdin
	fi # !bch_slr
    else # !bch
	# Interactive environment
	if [ -p /dev/stdin ] || [ ! -t 0 ]; then
	    # Interactive environments unambiguously cause -p to return true for stdin pipes
	    # Interactive environments unambiguously cause -t 0 to return false for stdin redirection
	    inp_std='Yes'
	fi # !stdin
    fi # !bch
    if [ ${inp_std} = 'Yes' ] && [ ${inp_psn} = 'Yes' ]; then
	echo "${spt_nm}: ERROR expecting input from both stdin and positional command-line arguments\n"
	exit 1
    fi # !inp_std
fi # !std_chk

# Derived variables
if [ -n "${drc_usr}" ]; then
    drc_out="${drc_usr%/}"
else
    if [ -n "${out_fl}" ]; then
	drc_out="$(dirname ${out_fl})"
    fi # !out_fl
fi # !drc_usr

if [ -n "${tmp_usr}" ]; then
    # Fancy %/ syntax removes trailing slash (e.g., from $TMPDIR)
    drc_tmp=${tmp_usr%/}
fi # !tmp_usr
dmm_fl="${drc_tmp}/ncremap_tmp_dmm.nc" # [sng] Dummy input file
grd_dst_dfl="${drc_tmp}/ncremap_tmp_grd_dst.nc" # [sng] Grid-file (destination) default
grd_src_dfl="${drc_tmp}/ncremap_tmp_grd_src.nc" # [sng] Grid-file (source) default
hnt_dst_fl="${drc_tmp}/ncremap_tmp_hnt_dst.txt" # [sng] Hint (for ERWG) destination
hnt_src_fl="${drc_tmp}/ncremap_tmp_hnt_src.txt" # [sng] Hint (for ERWG) source
ncwa_fl="${drc_tmp}/ncremap_tmp_ncwa.nc" # [sng] ncwa workflow (HIRDLS, MLS) default
nnt_fl="${drc_tmp}/ncremap_tmp_nnt.nc" # [sng] Annotated global datafile (RRG) default
rgn_fl="${drc_tmp}/ncremap_tmp_rgn.nc" # [sng] Regional file with coordinates (RRG) default
tmp_out_fl="${drc_tmp}/ncremap_tmp_out.nc" # [sng] Temporary output file
znl_fl="${drc_tmp}/ncremap_tmp_znl.nc" # [sng] Zonal workflow (HIRDLS, MLS) default

if [ -n "${unq_usr}" ]; then
    if [ "${unq_usr}" = 'noclean' ]; then
	cln_flg='No'
    else
	if [ "${unq_usr}" = 'none' ] || [ "${unq_usr}" = 'nil' ]; then
	    unq_sfx=""
	else # !unq_usr
	    unq_sfx="${unq_usr}"
	fi # !unq_usr
    fi # !unq_usr
fi # !unq_usr
dmm_fl=${dmm_fl}${unq_sfx}
grd_dst_dfl=${grd_dst_dfl}${unq_sfx}
grd_src_dfl=${grd_src_dfl}${unq_sfx}
hnt_dst_fl=${hnt_dst_fl}${unq_sfx}
hnt_src_fl=${hnt_src_fl}${unq_sfx}
ncwa_fl=${ncwa_fl}${unq_sfx}
nnt_fl=${nnt_fl}${unq_sfx}
rgn_fl=${rgn_fl}${unq_sfx}
tmp_out_fl=${tmp_out_fl}${unq_sfx}
znl_fl=${znl_fl}${unq_sfx}

# Algorithm options are bilinear|conserve|conserve2nd|nearestdtos|neareststod|patch|tempest|se2fv_flx|se2fv_stt|se2fv_alt|se2se|fv2se_flx|fv2se_stt|fv2se_alt|fv2fv_flx|fv2fv_stt|nco
if [ ${alg_typ} = 'bilinear' ] || [ ${alg_typ} = 'bilin' ] || [ ${alg_typ} = 'blin' ] || [ ${alg_typ} = 'bln' ]; then 
    alg_opt='bilinear'
elif [ ${alg_typ} = 'conserve' ] || [ ${alg_typ} = 'conservative' ] || [ ${alg_typ} = 'cns' ] || [ ${alg_typ} = 'c1' ] || [ ${alg_typ} = 'aave' ]; then 
    alg_opt='conserve'
elif [ ${alg_typ} = 'conserve2nd' ] || [ ${alg_typ} = 'conservative2nd' ] || [ ${alg_typ} = 'c2' ] || [ ${alg_typ} = 'c2nd' ]; then 
    alg_opt='conserve2nd'
elif [ ${alg_typ} = 'nearestdtos' ] || [ ${alg_typ} = 'ndtos' ] || [ ${alg_typ} = 'dtos' ] || [ ${alg_typ} = 'nds' ]; then 
    alg_opt='nearestdtos'
elif [ ${alg_typ} = 'neareststod' ] || [ ${alg_typ} = 'nstod' ] || [ ${alg_typ} = 'stod' ] || [ ${alg_typ} = 'nsd' ]; then 
    alg_opt='neareststod'
elif [ ${alg_typ} = 'patch' ] || [ ${alg_typ} = 'patc' ] || [ ${alg_typ} = 'pch' ]; then 
    alg_opt='patch'
elif [ ${alg_typ} = 'tempest' ] || [ ${alg_typ} = 'tps' ] || [ ${alg_typ} = 'tmp' ]; then 
    # 20171108 'tempest' invokes TempestRemap with no automatic options, suitable for RLL re-mapping?
    # 20171108 TempestRemap boutique options based on particular remapping type
    # 20200221 Add --correct_areas to many TR maps as per Transition to TR page
    # https://acme-climate.atlassian.net/wiki/spaces/Docs/pages/178848194/Transition+to+TempestRemap+for+Atmosphere+grids
    # alg_sng in comments is for E3SM naming convention map_src_to_dst_${alg_sng}.${dt_sng}.nc
    alg_opt='tempest'
    wgt_typ='tempest'
    if [ -n "${wgt_opt_usr}" ]; then 
	printf "${spt_nm}: INFO Specifying the TempestRemap default algorithm '--alg_typ=tempest' without giving any additional options with -W (--wgt_opt) works only for the default TR configuration where both input and output grids are Finite Volume (FV) grids. The default TR algorithm is conservative and non-monotonic.\n"
    fi # !wgt_opt_usr    
elif [ ${alg_typ} = 'se2fv_flx' ] || [ ${alg_typ} = 'mono_se2fv' ] || [ ${alg_typ} = 'conservative_monotone_se2fv' ]; then # alg_sng='mono'
    wgt_opt_tps="--in_type cgll --in_np ${np_se_nbr} --out_type fv --mono --correct_areas"
    alg_opt='se2fv_flx'
    wgt_typ='tempest'
elif [ ${alg_typ} = 'se2fv_stt' ] || [ ${alg_typ} = 'highorder_se2fv' ] || [ ${alg_typ} = 'accurate_conservative_nonmonotone_se2fv' ]; then # alg_sng='highorder'
    wgt_opt_tps="--in_type cgll --in_np ${np_se_nbr} --out_type fv --correct_areas"
    alg_opt='se2fv_stt'
    wgt_typ='tempest'
elif [ ${alg_typ} = 'se2fv_alt' ] || [ ${alg_typ} = 'intbilin_se2fv' ] || [ ${alg_typ} = 'accurate_monotone_nonconservative_se2fv' ]; then # alg_sng='intbilin'
    wgt_opt_tps="--in_type cgll --in_np ${np_se_nbr} --out_type fv --mono3 --noconserve --correct_areas"
    alg_opt='se2fv_alt'
    wgt_typ='tempest'
elif [ ${alg_typ} = 'se2se' ] || [ ${alg_typ} = 'cs2cs' ] || [ ${alg_typ} = 'conservative_monotone_se2se' ]; then # alg_sng='se2se'
    # 20190227: Add mono for se2se per recommendation of Mark Taylor
    wgt_opt_tps="--in_type cgll --in_np ${np_se_nbr} --out_type cgll --out_np ${np_se_nbr} --mono"
    alg_opt='se2se'
    wgt_typ='tempest'
elif [ ${alg_typ} = 'fv2se_flx' ] || [ ${alg_typ} = 'monotr_fv2se' ] || [ ${alg_typ} = 'conservative_monotone_fv2se' ]; then # alg_sng='monotr'
    # NB: Generate mono map for opposite direction regridding (i.e., reverse switches and grids), then transpose
    wgt_opt_tps="--in_type cgll --in_np ${np_se_nbr} --out_type fv --mono --correct_areas"
    alg_opt='fv2se_flx'
    wgt_typ='tempest'
    trn_map='Yes'
elif [ ${alg_typ} = 'fv2se_stt' ] || [ ${alg_typ} = 'highorder_fv2se' ] || [ ${alg_typ} = 'accurate_conservative_nonmonotone_fv2se' ]; then # alg_sng='highorder'
    # 20190716: Remove "--volumetric" from fv2se_stt per Mark Taylor and Paul Ullrich
    wgt_opt_tps="--in_type fv --in_np 2 --out_type cgll --out_np ${np_se_nbr}"
    alg_opt='fv2se_stt'
    wgt_typ='tempest'
elif [ ${alg_typ} = 'fv2se_alt' ] || [ ${alg_typ} = 'mono_fv2se' ] || [ ${alg_typ} = 'conservative_monotone_fv2se_alt' ]; then # alg_sng='mono'
    # 20200525: Remove "--volumetric" from fv2se_mono per Mark Taylor modifying Confluence instructions
    wgt_opt_tps="--in_type fv --in_np 1 --out_type cgll --out_np ${np_se_nbr} --mono"
    alg_opt='fv2se_alt'
    wgt_typ='tempest'
elif [ ${alg_typ} = 'fv2fv' ] || [ ${alg_typ} = 'rll2rll' ]; then # alg_sng='highorder'
    # 20190227: Add --mono3 --noconserve for fv2fv per (misinterpreted)recommendation of Mark Taylor
    # 20200115: Replace --mono3 --noconserve with --in_np 2 per recommendation of Mark Taylor and Paul Ullrich
    wgt_opt_tps='--in_type fv --in_np 2 --out_type fv'
    alg_opt='fv2fv'
    wgt_typ='tempest'
elif [ ${alg_typ} = 'fv2fv_flx' ] || [ ${alg_typ} = 'fv2fv_mono' ] || [ ${alg_typ} = 'conservative_monotone_fv2fv' ]; then # alg_sng='mono'
    # 20191115: Add per recommendation of Paul Ullrich
    # 20200221: Add --out_np 1 per (new?) settings in on Transition to TR page
    wgt_opt_tps='--in_type fv --in_np 1 --out_type fv --out_np 1 --correct_areas'
    alg_opt='fv2fv_flx'
    wgt_typ='tempest'
elif [ ${alg_typ} = 'fv2fv_stt' ] || [ ${alg_typ} = 'fv2fv_highorder' ] || [ ${alg_typ} = 'accurate_conservative_nonmonotone_fv2fv' ]; then # alg_sng='highorder'
    # 20191115: Add per recommendation of Paul Ullrich
    wgt_opt_tps='--in_type fv --in_np 2 --out_type fv --correct_areas'
    alg_opt='fv2fv_stt'
    wgt_typ='tempest'
elif [ ${alg_typ} = 'nco_con' ] || [ ${alg_typ} = 'nco_cns' ] || [ ${alg_typ} = 'nco_conserve' ] || [ ${alg_typ} = 'nco' ]; then 
    alg_opt='nco_con'
    wgt_typ='nco'
elif [ ${alg_typ} = 'nco_nni' ] || [ ${alg_typ} = 'nco_nnn' ] || [ ${alg_typ} = 'nco_distance_weighted' ] || [ ${alg_typ} = 'nco_nearest_neighbor' ]; then
    alg_opt='nco_nni'
    wgt_typ='nco'
else 
    echo "${spt_nm}: ERROR ${alg_typ} is not a valid weight-generation algorithm"
    echo "${spt_nm}: HINT Valid ESMF weight-generation algorithms and synonyms are bilinear,bilin,bln | conserve,cns,c1,aave | conserve2nd,c2,c2nd | nearestdtos,nds,dtos | neareststod,nsd,stod | patch,pch"
    echo "${spt_nm}: HINT Valid NCO weight-generation algorithms and synonyms are nco_con,nco_cns,nco_conserve,nco | nco_nni,nco_nnn,nco_dwe"
    echo "${spt_nm}: HINT Valid TempestRemap weight-generation options and synonyms are tempest | se2fv_flx,mono_se2fv | se2fv_stt,highorder_se2fv | se2fv_alt,intbilin | se2se,cs2cs | fv2se_flx,monotr_fv2se | fv2se_stt,highorder_fv2se | fv2se_alt,mono_fv2se | fv2fv,rll2rll"
    exit 1
fi # !alg_typ
# NB: As of 20190215 ncremap has never used gll_fl for E3SM, though I think Tempest does support it
if [ -n "${gll_fl}" ]; then
    if [ "${alg_opt}" = 'se2fv_flx' ] || [ "${alg_opt}" = 'se2fv_stt' ] || [ "${alg_opt}" = 'se2fv_alt' ] || [ "${alg_opt}" = 'fv2se_flx' ]; then
	wgt_opt_tps="--in_meta ${gll_fl} ${wgt_opt_tps}"
    elif [ "${alg_opt}" = 'fv2se_stt' ] || [ "${alg_opt}" = 'fv2se_alt' ]; then
	wgt_opt_tps="${wgt_opt_tps} --out_meta ${gll_fl}"
    fi # !se2fv || fv2se_flx
fi # !gll_fl
if [ -n "${fl_fmt}" ]; then
    if [ "${fl_fmt}" = '3' ] || [ "${fl_fmt}" = 'classic' ] || [ "${fl_fmt}" = 'netcdf3' ]; then
	nco_fl_fmt='--fl_fmt=classic'
	wgt_opt_tps="${wgt_opt_tps} --out_format Classic"
	msh_opt_tps="${msh_opt_tps} --out_format Classic"
    fi # !fl_fmt
    if [ "${fl_fmt}" = '4' ] || [ "${fl_fmt}" = 'netcdf4' ] || [ "${fl_fmt}" = 'hdf5' ]; then
	nco_fl_fmt='--fl_fmt=netcdf4'
	if [ -n "${erwg_vrs_mjr}" ]; then
	    if [ "${erwg_vrs_mjr}" -ge 6 ]; then
		wgt_opt_esmf="${wgt_opt_esmf} --netcdf4"
	    fi # !erwg_vrs_mjr
	fi # !erwg_vrs_mjr
	wgt_opt_tps="${wgt_opt_tps} --out_format Netcdf4"
	msh_opt_tps="${msh_opt_tps} --out_format Netcdf4"
    fi # !fl_fmt
    if [ "${fl_fmt}" = '5' ] || [ "${fl_fmt}" = '64bit_data' ] || [ "${fl_fmt}" = 'cdf5' ]; then
	nco_fl_fmt='--fl_fmt=64bit_data'
#	wgt_opt_esmf="${wgt_opt_esmf} --64bit_offset" # Change when ERWG supports CDF5
    fi # !fl_fmt
    if [ "${fl_fmt}" = '6' ] || [ "${fl_fmt}" = '64bit_offset' ] || [ "${fl_fmt}" = '64' ]; then
	nco_fl_fmt='--fl_fmt=64bit_offset'
	wgt_opt_esmf="${wgt_opt_esmf} --64bit_offset"
	wgt_opt_tps="${wgt_opt_tps} --out_format Offset64Bits"
	msh_opt_tps="${msh_opt_tps} --out_format Offset64Bits"
    fi # !fl_fmt
    if [ "${fl_fmt}" = '7' ] || [ "${fl_fmt}" = 'netcdf4_classic' ]; then
	nco_fl_fmt='--fl_fmt=netcdf4_classic'
	if [ -n "${erwg_vrs_mjr}" ]; then
	    if [ "${erwg_vrs_mjr}" -ge 6 ]; then
		wgt_opt_esmf="${wgt_opt_esmf} --netcdf4" # Change when ERWG supports netCDF7
	    fi # !erwg_vrs_mjr
	fi # !erwg_vrs_mjr
	wgt_opt_tps="${wgt_opt_tps} --out_format Netcdf4Classic"
	msh_opt_tps="${msh_opt_tps} --out_format Netcdf4Classic"
    fi # !fl_fmt
    nco_opt="${nco_fl_fmt} ${nco_opt}"
fi # !fl_fmt
if [ -n "${xtr_nsp_usr}" ]; then
    xtr_nsp=${xtr_nsp_usr}
fi # !xtr_nsp_usr
if [ -n "${xtr_xpn_usr}" ]; then
    xtr_xpn=${xtr_xpn_usr}
fi # !xtr_xpn_usr
if [ -n "${esmf_typ}" ]; then
    if [ ${esmf_typ} = 'neareststod' ] || [ ${esmf_typ} = 'stod' ] || [ ${esmf_typ} = 'nsd' ]; then 
	esmf_opt='neareststod'
    elif [ ${esmf_typ} = 'nearestidavg' ] || [ ${esmf_typ} = 'idavg' ] || [ ${esmf_typ} = 'id' ]; then 
	esmf_opt='nearestidavg'
    elif [ ${esmf_typ} = 'none' ] || [ ${esmf_typ} = 'nil' ] || [ ${esmf_typ} = 'nowaydude' ]; then 
	esmf_opt='none'
    else 
	echo "${spt_nm}: ERROR ${esmf_typ} is not a valid extrapolation method"
	echo "${spt_nm}: HINT Valid ESMF extrapolation methods and synonyms are neareststod,stod,nsd | nearestidavg,idavg,id | none,nil"
	exit 1
    fi # !esmf_typ
    wgt_opt_esmf="${wgt_opt_esmf} --extrap_method ${esmf_opt} --extrap_num_src_pnts ${xtr_nsp} --extrap_dist_exponent ${xtr_xpn}"
fi # !esmf_typ
if [ ${wgt_typ} = 'esmf' ]; then
    wgt_cmd="${wgt_exe_esmf}"
    wgt_exe="${wgt_exe_esmf}"
    wgt_opt="${wgt_opt_esmf}"
elif [ ${wgt_typ} = 'nco' ]; then
    if [ "${alg_opt}" = 'nco_nni' ]; then
	wgt_opt_nco="${wgt_opt_nco} --xtr_nsp=${xtr_nsp} --xtr_xpn=${xtr_xpn}"
    fi # alg_opt
    wgt_cmd="${wgt_exe_nco}"
    wgt_exe="${wgt_exe_nco}"
    wgt_opt="${wgt_opt_nco}"
elif [ ${wgt_typ} = 'tempest' ]; then
    wgt_cmd="${wgt_exe_tps}"
    wgt_exe="${wgt_exe_tps}"
    wgt_opt="${wgt_opt_tps}"
else 
    echo "${spt_nm}: ERROR ${wgt_typ} is not a valid weight-type"
    exit 1
fi # !wgt_typ
# NB: Define after wgt_typ-block so user can override default options
if [ -n "${wgt_opt_usr}" ]; then 
    wgt_opt=${wgt_opt_usr}
fi # !wgt_opt_usr    
if [ -n "${wgt_usr}" ]; then 
    wgt_cmd=${wgt_usr}
fi # !wgt_usr    

if [ -z "${drc_in}" ]; then
    drc_in="${drc_pwd}"
else # !drc_in
    if [ ! -d "${drc_in}" ]; then
	echo "${spt_nm}: ERROR specified input directory \"${drc_in}\" does not exist"
	exit 1
    fi # !drc_in
    drc_in_usr_flg='Yes'
fi # !drc_in
if [ -n "${in_fl}" ]; then
    inp_aut='Yes'
fi # !in_fl
if [ -n "${job_usr}" ]; then 
    job_nbr="${job_usr}"
fi # !job_usr
if [ -n "${mss_val_usr}" ]; then 
    mss_val=${mss_val_usr}
    att_flg='Yes'
fi # !mss_val_usr    
if [ ${dbg_lvl} -ge 2 ]; then
    nco_opt="--dbg_lvl=${dbg_lvl} ${nco_opt}"
fi # !dbg_lvl
if [ -n "${ppc_prc}" ]; then
    nco_opt="${nco_opt} --ppc default=${ppc_prc}"
fi # !ppc_prc
if [ -n "${dfl_lvl}" ]; then
    nco_opt="${nco_opt} --dfl_lvl=${dfl_lvl}"
fi # !dfl_lvl
if [ "${dvn_flg}" = 'Yes' ]; then
    devnull=' > /dev/null'
else
    devnull=''
fi # !dfl_lvl
if [ -n "${hdr_pad}" ]; then 
    nco_opt="${nco_opt} --hdr_pad=${hdr_pad}"
fi # !hdr_pad
if [ -n "${uio_flg}" ]; then
    nco_opt="${nco_opt} --unbuffered_io"
fi # !ppc_prc
if [ -n "${gaa_sng}" ]; then 
    nco_opt="${nco_opt} ${gaa_sng}"
fi # !gaa_sng
if [ "${no_cll_msr}" = 'Yes' ]; then 
    nco_opt="${nco_opt} --no_cll_msr"
fi # !no_cll_msr
if [ "${no_frm_trm}" = 'Yes' ]; then 
    nco_opt="${nco_opt} --no_frm_trm"
fi # !no_frm_trm
if [ "${no_stg_grd}" = 'Yes' ]; then 
    rgr_opt="${rgr_opt} --rgr no_stagger"
fi # !no_stg_grd
if [ -n "${prs_stt}" ]; then 
    if [ "${prs_stt}" != 'mean' ] && [ "${prs_stt}" != 'integral' ]; then 
	echo "${spt_nm}: ERROR \"${prs_stt}\" is an invalid value for preserved_statistic"
	echo "${spt_nm}: HINT The only two valid values for preserved_statistic are \"mean\" and \"integral\""
	exit 1
    fi # !prs_stt
    if [ "${prs_stt}" = 'mean' ] && [ -z "${rnr_thr}" ] ; then 
	rnr_thr=0.0
    fi # !prs_stt
    if [ "${prs_stt}" = 'integral' ] && [ -n "${rnr_thr}" ] ; then 
	if [ "${rnr_thr}" != 'off' ] && [ "${rnr_thr}" != 'none' ]; then
	    echo "${spt_nm}: ERROR preserved_statistic = \"${prs_stt}\" conflicts with rnr_thr=${rnr_thr}"
	    echo "${spt_nm}: HINT Explicitly specifying \"integral\" for the preserved-statistic is the same as turning-off renormalization so do not specify any value for renormalization"
	    exit 1
	fi # !rnr_thr
    fi # !prs_stt
fi # !prs_stt
if [ -n "${rnr_thr}" ]; then 
    if [ "${rnr_thr}" != 'off' ] && [ "${rnr_thr}" != 'none' ]; then 
	rgr_opt="${rgr_opt} --rnr_thr=${rnr_thr}"
    fi # !rnr_thr
fi # !rnr_thr
if [ -n "${var_lst}" ]; then 
    if [ "${xcl_flg}" = 'Yes' ]; then
	nco_var_lst="-x -v ${var_lst}"
    else
	nco_var_lst="-v ${var_lst}"
    fi # !xcl_flg
fi # !var_lst
if [ -n "${msk_dst}" ]; then 
    nco_msk_dst="--rgr msk_var=${msk_dst}"
fi # !msk_dst
if [ -n "${msk_out}" ]; then 
    nco_msk_out="--rgr msk_var=${msk_out}"
fi # !msk_out
if [ -n "${msk_src}" ]; then 
    nco_msk_src="--rgr msk_var=${msk_src}"
fi # !msk_src
if [ -n "${skl_fl}" ]; then 
    nco_skl_fl="--rgr skl=\"${skl_fl}\""
fi # !skl_fl
if [ -n "${ugrid_fl}" ]; then 
    nco_ugrid_fl="--rgr ugrid=\"${ugrid_fl}\""
fi # !ugrid_fl
if [ -n "${var_rgr}" ]; then 
    nco_var_rgr="--rgr_var=${var_rgr}"
fi # !var_rgr
if [ -n "${xtn_var}" ]; then 
    rgr_opt="${rgr_opt} --xtn=${xtn_var}"
fi # !var_lst
if [ -n "${out_fl}" ]; then 
    out_usr_flg='Yes'
fi # !out_fl
if [ "${par_typ}" = ${par_bck} ] || [[ "${par_typ}" =~ [bB]ck ]] || [[ "${par_typ}" =~ [bB]ackground ]]; then 
    par_typ=${par_bck}
    par_opt=' &'
elif [ "${par_typ}" = ${par_mpi} ] || [[ "${par_typ}" =~ (mpi|MPI) ]]; then 
    par_typ=${par_mpi}
    par_opt=' &'
    mpi_flg='Yes'
elif [ "${par_typ}" = ${par_srl} ] || [ "${par_typ}" = 'srl' ] || [[ "${par_typ}" =~ [sS]erial ]] || [[ "${par_typ}" =~ [nN]il ]] || [[ "${par_typ}" =~ [nN]one ]]; then 
    par_typ=${par_srl}
else 
    echo "ERROR: Invalid -p par_typ option = ${par_typ}"
    echo "HINT: Valid par_typ arguments include '${par_bck}' (or 'bck'), '${par_mpi}' (or 'MPI'), and '${par_srl}' (or 'srl' or 'nil' or 'none'). For background parallelism, select '${par_bck}' which causes ${spt_nm} to spawn parallel processes as background tasks on a single node. For MPI parallelism, select '${par_mpi}' which causes ${spt_nm} to spawn parallel processes on across available cluster nodes. For no parallelism (aka serial mode), select '${par_srl}', which causes ${spt_nm} to spawn all processes serially on a single compute node."
    exit 1
fi # !par_typ
if [ -n "${prc_typ}" ]; then
    if [ "${prc_typ}" != 'airs' ] && [ "${prc_typ}" != 'clm' ] && [ "${prc_typ}" != 'cice' ] && [ "${prc_typ}" != 'ctsm' ] && [ "${prc_typ}" != 'elm' ] && [ "${prc_typ}" != 'hirdls' ] && [ "${prc_typ}" != 'mls' ] && [ "${prc_typ}" != 'mod04' ] && [ "${prc_typ}" != 'mpas' ] && [ "${prc_typ}" != 'mpascice' ] && [ "${prc_typ}" != 'mpasseaice' ] && [ "${prc_typ}" != 'mwf' ] && [ "${prc_typ}" != 'nil' ] && [ "${prc_typ}" != 'rrg' ] && [ "${prc_typ}" != 'sgs' ]; then 
	    echo "ERROR: Invalid -P prc_typ option = ${prc_typ}"
	    echo "HINT: Valid prc_typ arguments are 'airs', 'clm', 'cice', 'ctsm', 'elm', 'hirdls', 'mls', 'mod04', 'mpas', 'mpascice', 'mpasseaice', 'mwf', 'nil', 'rrg', and 'sgs'"
	    exit 1
    fi # !prc_typ
fi # !prc_typ
if [ "${prc_typ}" = 'airs' ]; then 
    if [ -z "${pdq_opt}" ]; then 
	pdq_opt='-a StdPressureLev,GeoTrack,GeoXTrack'
    fi # !pdq_opt
fi # !airs
if [ "${prc_typ}" = 'hirdls' ]; then 
    if [ -z "${pdq_opt}" ]; then 
	pdq_opt='-a Pressure,Latitude,lon'
    fi # !pdq_opt
fi # !hirdls
if [ "${prc_typ}" = 'mls' ]; then 
    if [ -z "${pdq_opt}" ]; then 
	pdq_opt='-a CO_Pressure,CO_Latitude,lon'
    fi # !pdq_opt
fi # !mls
if [ "${prc_typ}" = 'mod04' ]; then 
    if [ -z "${pdq_opt}" ]; then 
	pdq_opt='-U'
    fi # !pdq_opt
    hnt_dst='--dst_regional'
fi # !mod04
if [ "${prc_typ}" = 'mpas' ] || [ "${prc_typ}" = 'mpascice' ] || [ "${prc_typ}" = 'mpasseaice' ]; then 
    prc_mpas='Yes'
fi # !mpas, !mpascice, !mpasseaice
if [ "${prc_mpas}" = 'Yes' ]; then 

    # Add/alter missing metadata to MPAS files unless script was invoked by ncclimo
    if [ "${clm_flg}" = 'No' ]; then
	att_flg='Yes'
    fi # !clm_flg

    # Add depth coordinate to MPAS file when requested to by specifying coordinate file, that file exists, and commmand is found
    if [ -n "${dpt_fl}" ] || [ "${dpt_flg}" = 'Yes' ]; then
	if [ -n "${dpt_fl}" ]; then
	    if [ ! -f "${dpt_fl}" ]; then
		echo "ERROR: Unable to find specified MPAS depth coordinate file ${dpt_fl}"
		exit 1
	    fi # ! -f
	    cmd_dpt_opt="-c \"${dpt_fl}\""
	fi # !dpt_fl
	if [ -z "${cmd_dpt_mpas}" ]; then
	    printf "${spt_nm}: ERROR MPAS depth coordinate addition requested but command ${dpt_exe_mpas} not found\n"
	fi # !err
	dpt_flg='Yes'
    fi # !dpt_fl
    if [ -z "${pdq_opt}" ]; then
#	pdq_opt='-a Time,nVertLevels,maxEdges,MaxEdges2,nEdges,nCells' # MPAS-Ocean
#	pdq_opt='-a Time,nCategories,ONE,nEdges,nCells' # MPAS-SeaIce
#	pdq_opt='-a Time,nCategories,TWO,nEdges,nCells' # MPAS-LandIce
#	pdq_opt='-a Time,depth,nVertLevels,nVertLevelsP1,maxEdges,MaxEdges2,nCategories,ONE,TWO,nEdges,nCells' # MPAS O,SI,LI and depth
#	pdq_opt='-a Time,depth,nVertLevels,nVertLevelsP1,maxEdges,MaxEdges2,nCategories,R3,ONE,TWO,FOUR,nEdges,nCells' # 20190806: MPAS O,SI,LI,depth and BGC in one swell foop
	pdq_opt='-a Time,depth,nVertLevels,nVertLevelsP1,nZBGCTracers,nBioLayersP1,nAlgaeIceLayers,nDisIronIceLayers,nIceLayers,maxEdges,MaxEdges2,nCategories,R3,ONE,TWO,FOUR,nEdges,nCells' # 20200620: MPAS O,SI,LI,depth and new SI BGC in one swell foop
    fi # !pdq_opt
    if [ -n "${rnr_thr}" ]; then 
	# rnr_thr='off' in MPAS mode turns-off renormalization
	if [ "${rnr_thr}" != 'off' ]; then 
	    rgr_opt="${rgr_opt} --rnr_thr=${rnr_thr}"
	fi # !rnr_thr
    elif [ -z "${prs_stt}" ]; then 
	# Default MPAS behavior (since forever) has been to renormalize
	rgr_opt="${rgr_opt} --rnr_thr=0.0"
    fi # !rnr_thr
    # 20181130 No known reason to include staggered grid with regridded MPAS data
    rgr_opt="${rgr_opt} --rgr no_stagger"
fi # !mpas
if [ "${prc_typ}" = 'mwf' ]; then 
    [[ ${dbg_lvl} -ge 1 ]] && date_mwf=$(date +"%s")
    # Assume destination grid-files that end in .nc are SCRIP (and thus FV), and .g means Exodus (and thus SE)
    # https://stackoverflow.com/questions/407184/how-to-check-the-extension-of-a-filename-in-a-bash-script
    if [[ ${grd_dst} == *.g ]]; then
	alg_lst='fv2se_flx fv2se_stt fv2se_alt'
    else
	if [ -n "${wgt_opt_usr}" ] && [ "${wgt_opt_usr}" = 'tempest' ]; then
	    alg_lst='fv2fv tempest'
	else # !wgt_opt_usr
	    alg_lst='aave blin ndtos nstod patc'
	fi # !wgt_opt_usr
    fi # !grd_dst
    # Compute FV->SE maps
    if [ -n "${hnt_src}" ]; then
       hnt_src_sng="--hnt_src=${hnt_src}"
    fi # !hnt_src
    if [ -n "${hnt_dst}" ]; then
       hnt_dst_sng="--hnt_dst=${hnt_dst}"
    fi # !hnt_dst	
    for alg_typ in ${alg_lst}; do
	alg_sng=${alg_typ}
	[[ ${alg_typ} = 'fv2se_flx' ]] && alg_sng='monotr'
	[[ ${alg_typ} = 'fv2se_stt' ]] && alg_sng='highorder'
	[[ ${alg_typ} = 'fv2se_alt' ]] && alg_sng='mono'
	map_nm="${drc_out}/map_${nm_src}_to_${nm_dst}_${alg_sng}.${dt_sng}.nc"
	wgt_sng=''
	if [ -n "${wgt_usr}" ]; then 
	    erwg_alg_typ_rx='aave blin ndtos nstod patc'
	    # https://stackoverflow.com/questions/229551/string-contains-a-substring-in-bash
	    if [[ ${erwg_alg_typ_rx} = *"${alg_typ}"* ]]; then
		wgt_sng="--wgt_cmd='${wgt_usr}'"
	    fi # !ERWG
	fi # !wgt_usr
	if [ ${vrb_lvl} -ge ${vrb_3} ]; then
	    printf "MWF: Create ${alg_typ} map ${map_nm}\n"
	fi # !vrb_lvl
	cmd_mwf="ncremap ${wgt_sng} --alg_typ=${alg_typ} --grd_src=\"${grd_src}\" --grd_dst=\"${grd_dst}\" ${hnt_src_sng} ${hnt_dst_sng} --map_fl=\"${map_nm}\""
	if [ ${dbg_lvl} -ge 1 ]; then
	    echo ${cmd_mwf}
	fi # !dbg
	if [ ${dbg_lvl} -ne 2 ]; then
	    eval ${cmd_mwf}
	    if [ "$?" -ne 0 ]; then
		printf "${spt_nm}: ERROR Failed to generate MWF map. Debug this:\n${cmd_mwf}\n"
		exit 1
	    fi # !err
	fi # !dbg
	if [ ${dbg_lvl} -ge 1 ]; then
	    date_crr=$(date +"%s")
	    date_dff=$((date_crr-date_mwf))
	    echo "Elapsed time to generate ${alg_typ} map $((date_dff/60))m$((date_dff % 60))s"
	fi # !dbg
    done # !alg_typ
    # Compute SE->FV maps
    if [[ ${grd_dst} == *.g ]]; then 
	alg_lst='se2fv_flx se2fv_stt se2fv_alt'
    else
	if [ -n "${wgt_opt_usr}" ] && [ "${wgt_opt_usr}" = 'tempest' ]; then
	    alg_lst='fv2fv tempest'
	else # !wgt_opt_usr
	    alg_lst='aave blin ndtos nstod patc'
	fi # !wgt_opt_usr
    fi # !grd_dst
    if [ -n "${hnt_src}" ]; then 
       hnt_dst_sng="--hnt_dst=${hnt_src/src/dst}"
    fi # !hnt_src
    if [ -n "${hnt_dst}" ]; then
       hnt_src_sng="--hnt_src=${hnt_dst/dst/src}"
    fi # !hnt_dst	
    for alg_typ in ${alg_lst}; do
	# Swap grd_src with grd_dst
	alg_sng=${alg_typ}
	[[ ${alg_typ} = 'se2fv_flx' ]] && alg_sng='mono'
	[[ ${alg_typ} = 'se2fv_stt' ]] && alg_sng='highorder'
	[[ ${alg_typ} = 'se2fv_alt' ]] && alg_sng='intbilin'
	map_nm="${drc_out}/map_${nm_dst}_to_${nm_src}_${alg_sng}.${dt_sng}.nc"
	# MWF-mode must be invoked with ocean as grd_src, atmosphere as grd_dst
	a2o_sng=''
	if [ "${alg_typ}" = 'se2fv_flx' ] || [ "${alg_typ}" = 'se2fv_stt' ] || [ "${alg_typ}" = 'se2fv_alt' ] || [ "${alg_typ}" = 'tempest' ]; then
	    a2o_sng='--a2o'
	fi # !alg_typ
	wgt_sng=''
	if [ -n "${wgt_usr}" ]; then 
	    erwg_alg_typ_rx='aave blin ndtos nstod patc'
	    # https://stackoverflow.com/questions/229551/string-contains-a-substring-in-bash
	    if [[ ${erwg_alg_typ_rx} = *"${alg_typ}"* ]]; then
		wgt_sng="--wgt_cmd='${wgt_usr}'"
	    fi # !ERWG
	fi # !wgt_usr
	if [ ${vrb_lvl} -ge ${vrb_3} ]; then
	    printf "MWF: Create ${alg_typ} map ${map_nm}\n"
	fi # !vrb_lvl
	cmd_fwm="ncremap ${wgt_sng} ${a2o_sng} --alg_typ=${alg_typ} --grd_src=\"${grd_dst}\" --grd_dst=\"${grd_src}\" ${hnt_src_sng} ${hnt_dst_sng} --map_fl=\"${map_nm}\""
	if [ ${dbg_lvl} -ge 1 ]; then
	    echo ${cmd_fwm}
	fi # !dbg
	if [ ${dbg_lvl} -ne 2 ]; then
	    eval ${cmd_fwm}
	    if [ "$?" -ne 0 ]; then
		printf "${spt_nm}: ERROR Failed to generate FWM map. Debug this:\n${cmd_fwm}\n"
		exit 1
	    fi # !err
	fi # !dbg
	if [ ${dbg_lvl} -ge 1 ]; then
	    date_crr=$(date +"%s")
	    date_dff=$((date_crr-date_mwf))
	    echo "Elapsed time to generate ${alg_typ} map $((date_dff/60))m$((date_dff % 60))s"
	fi # !dbg
    done # !alg_typ
    echo "Finished MWF mode"
    exit 0
fi # !mwf
if [ "${prc_typ}" = 'rrg' ]; then 
    if [ -n "${dat_rgn}" ]; then # NB: option currently not implemented, drop it?
	fl_in[0]=${dat_rgn}
    fi # !dat_glb
    if [ -n "${dat_glb}" ]; then 
	if [ ! -f "${dat_glb}" ]; then
	    echo "ERROR: Unable to find specified global data file ${dat_glb}"
	    exit 1
	fi # ! -f
    else
	echo "${spt_nm}: ERROR Regional regridding requires global data coordinates in file specified with --rrg_dat_glb argument\n"
	exit 1
    fi # !dat_glb
    if [ -n "${grd_glb}" ]; then 
	if [ ! -f "${grd_glb}" ]; then
	    echo "ERROR: Unable to find specified SCRIP-format global grid file ${grd_glb}"
	    exit 1
	fi # ! -f
    else
	echo "${spt_nm}: ERROR Regional regridding requires SCRIP-format grid for global data in file specified with --rrg_grd_glb argument\n"
	exit 1
    fi # !grd_glb
    # User may specify final, regional destination grid with either -g or --rrg_grd_rgn
    if [ -n "${grd_rgn}" ]; then 
	grd_dst=${grd_rgn}
    else
	if [ -n "${grd_dst}" ]; then 
	    grd_rgn=${grd_dst}
	else
	    echo "${spt_nm}: ERROR Regional regridding requires SCRIP-format destination grid for regional data in file specified with --rrg_grd_rgn or --grd_dst argument\n"
	    exit 1
	fi # !grd_dst
    fi # !grd_rgn
    if [ ! -f "${grd_rgn}" ]; then
	echo "ERROR: Unable to find specified SCRIP-format regional grid file ${grd_rgn}"
	exit 1
    fi # ! -f
    grd_dst_usr_flg='Yes'
    hnt_dst='--dst_regional'
fi # !rrg
if [ "${prc_typ}" = 'clm' ] || [ "${prc_typ}" = 'ctsm' ] || [ "${prc_typ}" = 'elm' ]; then 
    # Set CLM/ELM-specific options first, then change prc_typ to sgs
    rds_rth='6.37122e6' # [m] Radius of Earth in CLM/CTSM/ELM (SHR_CONST_REARTH)
    sgs_frc='landfrac'
    sgs_msk='landmask'
    sgs_nrm='1.0'
    prc_elm='Yes'
fi # !clm, !ctsm, !elm
if [ "${prc_typ}" = 'cice' ]; then 
    # Set CICE-specific options first, then change prc_typ to sgs
    rds_rth='6371229.0' # [m] Radius of Earth in MPAS-SeaIce (global attribute sphere_radius)
    sgs_frc='aice'
    sgs_msk='tmask'
    sgs_nrm='100.0'
    prc_cice='Yes'
fi # !cice
if [ "${prc_typ}" = 'mpascice' ] || [ "${prc_typ}" = 'mpasseaice' ]; then 
    # NB: 'mpasseaice' is an exact synonym for 'mpascice' (which should be deprecated)
    # Set MPAS-SeaIce-specific options first, then change prc_typ to sgs
    # MPAS-SeaIce requires two modes, MPAS and SGS, so set prc_mpas to 'Yes'
    rds_rth='6371229.0' # [m] Radius of Earth in MPAS-SeaIce (global attribute sphere_radius)
    sgs_frc='timeMonthly_avg_iceAreaCell'
    # 20190326 timeMonthly_avg_icePresent contains fraction of time in averaging interval when any ice was present
    # Thus timeMonthly_avg_icePresent is a floating point fraction, not a traditional integer mask
    # 20190910 timeMonthly_avg_icePresent should be SGS regridded like any 2D field
    # Treat a field named timeMonthly_avg_icePresentIntMask, if present, as a traditional integer mask
    sgs_msk='timeMonthly_avg_icePresentIntMask'
    sgs_nrm='1.0'
    prc_mpas='Yes'
    prc_mpascice='Yes'
fi # !mpascice
if [ -n "${sgs_frc}" ]; then 
    prc_typ='sgs'
fi # !sgs
if [ "${prc_typ}" = 'sgs' ]; then
    if [ -z "${sgs_frc}" ]; then 
	sgs_frc='landfrac' # 20190924: Back-compatibility with NCO 4.8.1-
    fi # !sgs_frc
    if [ -z "${sgs_msk}" ]; then 
	sgs_msk='landmask' # 20190924: Back-compatibility with NCO 4.8.1-
    fi # !sgs_msk
    if [ -n "${sgs_frc}" ]; then
	rgr_opt="${rgr_opt} --rgr sgs_frc_nm=${sgs_frc}"
	if [ -n "${sgs_msk}" ]; then
	    rgr_opt="${rgr_opt}#sgs_msk_nm=${sgs_msk}"
	fi # !sgs_msk
    fi # !sgs_frc
fi # !sgs
if [ -n "${thr_usr}" ]; then 
    thr_nbr="${thr_usr}"
fi # !thr_usr
if [ -n "${vrt_fl}" ]; then
    if [ ! -f "${vrt_fl}" ]; then
	echo "ERROR: Unable to find specified vertical coordinate file ${vrt_fl}"
	exit 1
    fi # ! -f
    vrt_usr_flg='Yes'
    if [ -n "${vrt_nm}" ]; then
	vrt_opt="${vrt_opt} --rgr plev_nm=${vrt_nm}"
    fi # !vrt_nm
    if [ -n "${vrt_xtr}" ]; then
	if [ ${vrt_xtr} = 'mss_val' ] || [ ${vrt_xtr} = 'missing_value' ] || [ ${vrt_xtr} = 'msv' ]; then 
	    vrt_opt="${vrt_opt} --rgr xtr_mth=mss_val"
	elif [ ${vrt_xtr} = 'nrs_ngh' ] || [ ${vrt_xtr} = 'nearest_neighbor' ] || [ ${vrt_xtr} = 'nn' ]; then 
	    vrt_opt="${vrt_opt} --rgr xtr_mth=nrs_ngh"
	else 
	    echo "${spt_nm}: ERROR ${vrt_xtr} is not a valid extrapolation method"
	    echo "${spt_nm}: HINT Valid vertical extrapolation methods and synonyms are mss_val,missing_value,msv | nrs_ngh,nearest_neighbor,nn"
	    exit 1
	fi # !vrt_xtr
    fi # !vrt_xtr
    if [ -n "${vrt_ntp}" ]; then
	if [ ${vrt_ntp} = 'lin' ] || [ ${vrt_ntp} = 'linear' ] || [ ${vrt_ntp} = 'lnr' ]; then 
	    vrt_opt="${vrt_opt} --rgr ntp_mth=lin"
	elif [ ${vrt_ntp} = 'log' ] || [ ${vrt_ntp} = 'logarithmic' ] || [ ${vrt_ntp} = 'lgr' ]; then 
	    vrt_opt="${vrt_opt} --rgr ntp_mth=log"
	else 
	    echo "${spt_nm}: ERROR ${vrt_ntp} is not a valid interpolation method"
	    echo "${spt_nm}: HINT Valid vertical interpolation methods and synonyms are lin,linear,lnr | log,logarithmic,lgr"
	    exit 1
	fi # !vrt_ntp
    fi # !vrt_ntp
fi # !vrt_fl

if [ -n "${dst_fl}" ]; then 
    if [ ! -f "${dst_fl}" ]; then
	echo "ERROR: Unable to find specified destination-file ${dst_fl}"
	echo "HINT: Supply the full path-name for the destination-file"
	exit 1
    fi # ! -f
    dst_usr_flg='Yes'
fi # !dst_fl
if [ -z "${grd_sng}" ]; then 
    grd_sng_dfl="grd_ttl='Default internally-generated grid'#latlon=10,10#lat_typ=uni#lon_typ=Grn_ctr" # [sng] Grid string default
    grd_sng="${grd_sng_dfl}"
else
    grd_sng_usr_flg='Yes'
fi # !grd_sng
if [ -n "${grd_dst}" ]; then 
    if [ -f "${grd_dst}" ]; then
	if [ "${dst_usr_flg}" = 'Yes' ]; then
	    printf "${spt_nm}: WARNING ${grd_dst} already exists and will be overwritten by newly inferred grid\n"
	fi # !dst_usr_flg
	if [ "${grd_sng_usr_flg}" = 'Yes' ]; then
	    printf "${spt_nm}: WARNING ${grd_dst} already exists and will be overwritten by newly created grid\n"
	fi # !grd_sng_usr_flg
    else
	if [ "${dst_usr_flg}" != 'Yes' ] && [ "${grd_sng_usr_flg}" != 'Yes' ]; then
	    echo "ERROR: Unable to find specified destination grid-file ${grd_dst}"
	    echo "HINT: Supply full path-name for destination grid, or generate it with -G option and arguments"
	exit 1
	fi # !dst_usr_flg
    fi # ! -f
    grd_dst_usr_flg='Yes'
else
    grd_dst=${grd_dst_dfl} # [sng] Grid-file default
fi # !grd_dst
if [ -n "${grd_src}" ]; then 
    if [ "${prc_typ}" != 'rrg' ]; then 
	if [ ! -f "${grd_src}" ]; then
	    echo "ERROR: Unable to find specified source grid-file ${grd_src}"
	    exit 1
	fi # ! -f
	grd_src_usr_flg='Yes'
    fi # !rrg
else
    grd_src=${grd_src_dfl} # [sng] Grid-file default
fi # !grd_src
if [ "${dst_usr_flg}" = 'Yes' ] || [ "${grd_sng_usr_flg}" = 'Yes' ] || [ "${grd_dst_usr_flg}" = 'Yes' ] || [ "${grd_src_usr_flg}" = 'Yes' ]; then
    # Create map-file if -d, -G, -g, or -s was specified
    map_mk='Yes'
fi # !map_mk
if [ -n "${map_fl}" ]; then 
    map_usr_flg='Yes'
    if [ "${map_mk}" = 'Yes' ]; then
	# Confirm before overwriting maps
        if [ -f "${map_fl}" ]; then
	    # 20160803: fxm invoke iff in interactive shell (block hangs on read() in non-interactive shells)
#	    if [ -t 0 ] || [ ! -p /dev/stdin ]; then
#           if [ -n "${TERM}" ]; then
#           if [ -n "${PS1}" ]; then
            if [ 1 -eq 0 ]; then
		rsp_kbd_nbr=0
		while [ ${rsp_kbd_nbr} -lt 10 ]; do
		    echo "WARNING: Map-file ${map_fl} already exists and will be over-written."
		    read -p "Continue (y/n)? " rsp_kbd
		    let rsp_kbd_nbr+=1
		    case "${rsp_kbd}" in
			N*|n*) exit 1 ;;
			Y*|y*) break ;;
			*) continue ;;
		    esac
		done # !rsp_kbd_nbr
		if [ ${rsp_kbd_nbr} -ge 10 ]; then
		    echo "ERROR: Too many invalid responses, exiting"
		    exit 1
		fi # !rsp_kbd_nbr
	    fi # !0
	fi # !map_fl
    else # !map_mk
        if [ ! -f "${map_fl}" ]; then
	    echo "ERROR: Unable to find specified regrid map ${map_fl}"
	    echo "HINT: Supply a valid map-file (weight-file) name or supply the grid files or data files and let ncremap create a mapfile for you"
	    exit 1
	fi # ! -f
    fi # !map_mk
else # !map_fl
    map_fl_dfl="${drc_tmp}/ncremap_tmp_map_${wgt_typ}_${alg_opt}.nc${unq_sfx}" # [sng] Map-file default
    map_fl=${map_fl_dfl}
fi # !map_fl
map_rsl_fl=${map_fl}
if [ "${map_mk}" = 'Yes' ]; then
    if [ "${wgt_typ}" = 'nco' ]; then
	msh_fl_dfl="${drc_tmp}/ncremap_tmp_msh_ovr_${wgt_typ}.nc${unq_sfx}" # [sng] Mesh-file default
    elif [ "${wgt_typ}" = 'tempest' ]; then 
	msh_fl_dfl="${drc_tmp}/ncremap_tmp_msh_ovr_${wgt_typ}.g${unq_sfx}" # [sng] Mesh-file default
	if [ "${trn_map}" = 'Yes' ]; then
	    map_trn_fl="${drc_tmp}/ncremap_tmp_map_trn_${wgt_typ}.nc${unq_sfx}" # [sng] Map-file transpose default
	    map_rsl_fl=${map_trn_fl}
	fi # !trn_map
    fi # !tempest
    if [ -n "${msh_fl}" ] && [ "${wgt_typ}" = 'nco' ]; then
	msh_opt="--rgr msh=\"${msh_fl}\""
    else
	msh_fl=${msh_fl_dfl}
    fi # !msh_fl_usr
fi # !map_mk

# Read files from stdin pipe, positional arguments, or directory glob
# Code block taken from ncclimo
# ncclimo sets inp_aut flag when file list is automatically (i.e., internally) generated
# ncremap uses convention that input files specified with -i set inp_aut flag
# That way, ncremap code block looks closer to ncclimo without introducing a new "inp_cmd" flag
#printf "dbg: inp_aut  = ${inp_aut}\n"
#printf "dbg: inp_glb  = ${inp_glb}\n"
#printf "dbg: inp_psn  = ${inp_psn}\n"
#printf "dbg: inp_std  = ${inp_std}\n"
if [ ${inp_aut} = 'No' ] && [ ${inp_psn} = 'No' ] && [ ${inp_std} = 'No' ] && [ "${drc_in_usr_flg}" = 'Yes' ]; then
    inp_glb='Yes'
fi # !inp_psn, !inp_std
if [ "${map_mk}" != 'Yes' ] && [ ${inp_aut} = 'No' ] && [ ${inp_glb} = 'No' ] && [ ${inp_psn} = 'No' ] && [ ${inp_std} = 'No' ]; then
    echo "${spt_nm}: ERROR Specify input file(s) with -i \$in_fl or with -I \$drc_in or with positional argument(s) or with stdin"
    if [ ${bch_pbs} = 'Yes' ]; then
	echo "${spt_nm}: HINT PBS batch job environment detected, pipe to stdin not allowed, try positional arguments instead"
    else # !bch_pbs
	echo "${spt_nm}: HINT Pipe input file list to stdin with, e.g., 'ls *.nc | ${spt_nm}'"
    fi # !bch_pbs
    exit 1
fi # !sbs_flg
if [ ${inp_aut} = 'Yes' ]; then 
    # Single file argument
    fl_in[0]=${in_fl}
    fl_nbr=1
fi # !inp_aut
if [ ${inp_glb} = 'Yes' ]; then 
    for fl in "${drc_in}"/*.nc "${drc_in}"/*.nc3 "${drc_in}"/*.nc4 "${drc_in}"/*.cdf "${drc_in}"/*.hdf "${drc_in}"/*.he5 "${drc_in}"/*.h5 ; do
	if [ -f "${fl}" ]; then
	    fl_in[${fl_nbr}]=${fl}
	    let fl_nbr=${fl_nbr}+1
	fi # !file
    done
fi # !inp_glb
if [ ${inp_psn} = 'Yes' ]; then
    if [ ${psn_nbr} -eq 1 ]; then
	fl_in[0]=${1}
	fl_nbr=1
    elif [ ${psn_nbr} -eq 2 ]; then
	if [ -z "${out_fl}" ]; then
	    fl_in[0]=${1}
	    out_fl=${2}
	    out_usr_flg='Yes'
	    fl_nbr=1
	else # !out_fl
	    echo "ERROR: Output file specified with -o (${out_fl}) conflicts with second positional argument ${2}"
	    echo "HINT: Use -o out_fl or positional argument, not both"
	    exit 1
	fi # !out_fl
    elif [ ${psn_nbr} -ge 3 ]; then
	for ((psn_idx=1;psn_idx<=psn_nbr;psn_idx++)); do
	    fl_in[(${psn_idx}-1)]=${!psn_idx}
	    fl_nbr=${psn_nbr}
	done # !psn_idx
    fi # !psn_nbr
fi # !inp_psn
if [ ${inp_std} = 'Yes' ]; then
    # Input awaits on unit 0, i.e., on stdin
    while read -r line; do # NeR05 p. 179
	fl_in[${fl_nbr}]=${line}
	let fl_nbr=${fl_nbr}+1
    done < /dev/stdin
fi # !inp_std

if [ "${mpi_flg}" = 'Yes' ]; then
    if [ -n "${COBALT_NODEFILE}" ]; then 
	nd_fl="${COBALT_NODEFILE}"
    elif [ -n "${PBS_NODEFILE}" ]; then 
	nd_fl="${PBS_NODEFILE}"
    elif [ -n "${SLURM_NODELIST}" ]; then 
	# SLURM returns compressed lists (e.g., "nid00[076-078,559-567]")
	# Convert this to file with uncompressed list (like Cobalt, PBS)
	# http://www.ceci-hpc.be/slurm_faq.html#Q12
	nd_fl='ncremap.slurm_nodelist'
	nd_lst=`scontrol show hostname ${SLURM_NODELIST}`
	echo ${nd_lst} > ${nd_fl}
    else
	echo "${spt_nm}: ERROR MPI master process unable to find node-list for distributing jobs"
	echo "${spt_nm}: ${spt_nm} uses first node-list found in \$COBALT_NODEFILE, \$PBS_NODEFILE, or \$SLURM_NODELIST"
	echo "${spt_nm}: However, none of these environment variables are set so there is no node-list for distributing MPI jobs"
	echo "${spt_nm}: HINT: Requesting MPI-parallelism (i.e., invoking ${spt_nm} with \"-p mpi\") in a non-MPI environment will trigger this error. Use \"-p mpi\" only when one of the preceding schedulers has allocated (for interactive use) or will allocate (for non-interactive use) the compute nodes. Otherwise use the default background parallelism (use \"-p bck\" or omit the option completely) or use serial mode (use \"-p serial\"). See http://nco.sf.net/nco.html#par_typ for more information on parallelism."
	exit 1
    fi # !PBS
    if [ -n "${nd_fl}" ]; then 
	# NB: nodes are 0-based, e.g., [0..11]
	nd_idx=0
	for nd in `cat ${nd_fl} | uniq` ; do
	    nd_nm[${nd_idx}]=${nd}
	    let nd_idx=${nd_idx}+1
	done # !nd
	nd_nbr=${#nd_nm[@]}
	if [ "${nd_nbr}" -eq 0 ]; then
	    echo "${spt_nm}: ERROR MPI-mode node number nd_nbr = ${nd_nbr}"
	    echo "${spt_nm}: HINT Parsing the node-list for distributing MPI jobs failed"
	    exit 1
	fi # !nd_nbr
	for ((fl_idx=0;fl_idx<fl_nbr;fl_idx++)); do
	    # NB: ncclimo and ncremap employ different node-allocation algorithms:
	    # ncclimo (monthly climatology mode) assigns monthly regridding and seasonal climos to different nodes (i.e., load-balances), and likewise for seasonal-regridding and annual climo
	    # ncclimo (splitter mode) uses simple round robin based on position in variable list
	    # ncremap uses simple round-robin allocation based on position in input file list
	    # Only ncclimo monthly climatology-mode uses 1-based cmd_mpi array
	    # ncclimo splitter-mode, and daily and annual climatology-mode, and ncremap all use 0-based cmd_mpi array
	    # Copy host-specific mpirun syntax but not node-allocation algorithms between ncclimo and ncremap
	    case "${HOSTNAME}" in 
		# 20160502: Remove tasks-per-node limits (ntasks, npernode) so round-robin algorithm can schedule multiple jobs on same node
		blues* | blogin* | b[0123456789][0123456789][0123456789] | compy* | constance* | cori* | n[0123456789][0123456789][0123456789][0123456789] | nid* | node* | rhea* )
		    # 20160502: Non-interactive batch jobs at NERSC return HOSTNAME as nid*, not cori*
		    # 20160803: Non-interactive batch jobs at PNNL constance return HOSTNAME as node*, not constance*
		    # 20190526: Non-interactive batch jobs at PNNL compy return HOSTNAME as n????, not compy*
		    # NB: NERSC staff says srun automatically assigns to unique nodes even without "-L $node" argument?
 		    cmd_mpi[${mpi_idx}]="srun --nodelist ${nd_nm[$((${mpi_idx_zro} % ${nd_nbr}))]} --nodes=1" ; ;; # SLURM
# 		    cmd_mpi[${mpi_idx}]="srun --nodelist ${nd_nm[$((${mpi_idx_zro} % ${nd_nbr}))]} --nodes=1 --ntasks=1" ; ;; # SLURM
		*cheyenne* )
		    # 20180120: Non-interactive batch jobs at NCAR return HOSTNAME as cheyenne?
		    # Cheyenne prefers 'mpiexec_mpt dplace -s 1 ncclimo ...'
		    # Unsure how to specify nd_nm to mpiexec_mpt
		    # mpirun from SGI MPT does not accept '-H nd_nm', unlike regular PBS
		    # PBSPro considers ncclimo a 'non-MPT application' so must set MPI_SHEPHERD=true
		    export MPI_SHEPHERD=true
#		    cmd_mpi[${fl_idx}]="mpiexec_mpt dplace ${nd_nm[$((${fl_idx} % ${nd_nbr}))]} -n 1" ; ;; # PBSPro
		    cmd_mpi[${fl_idx}]="mpirun ${nd_nm[$((${fl_idx} % ${nd_nbr}))]} -n 1" ; ;; # PBSPro
		cooley* | cc[0123456789][0123456789][0123456789] | mira* ) 
		    # 20190310: Cooley mpirun now uses -hosts instead of -H for hostname option
		    cmd_mpi[${fl_idx}]="mpirun -hosts ${nd_nm[$((${fl_idx} % ${nd_nbr}))]} -n 1" ; ;; # ALCF
		theta* )
		    # NB: ALCF Theta (not cooley or mira) uses aprun:
		    # https://www.alcf.anl.gov/user-guides/example-program-and-makefile-xc40
		    cmd_mpi[${fl_idx}]="aprun -L ${nd_nm[$((${fl_idx} % ${nd_nbr}))]} -n 1" ; ;; # ALCF Theta
		* )
		    cmd_mpi[${fl_idx}]="mpirun -H ${nd_nm[$((${fl_idx} % ${nd_nbr}))]} -n 1" ; ;; # Other (Cobalt, PBS)
#		    cmd_mpi[${fl_idx}]="mpirun -H ${nd_nm[$((${fl_idx} % ${nd_nbr}))]} -npernode 1 -n 1" ; ;; # Other
	    esac # !HOSTNAME
	done # !fl_idx
	if [ -n "${SLURM_NODELIST}" ]; then 
	    /bin/rm -f ${nd_fl}
	fi # !SLURM
    else # !nd_fl
	mpi_flg='No'
	for ((fl_idx=0;fl_idx<fl_nbr;fl_idx++)); do
	    cmd_mpi[${fl_idx}]=""
	done # !fl_idx
    fi # !nd_fl
    if [ -z "${job_usr}" ]; then 
	job_nbr=${nd_nbr}
    fi # !job_usr
    if [ -z "${thr_usr}" ]; then 
	if [ -n "${PBS_NUM_PPN}" ]; then
#	NB: use export OMP_NUM_THREADS when thr_nbr > 8
#	thr_nbr=${PBS_NUM_PPN}
	    thr_nbr=$((PBS_NUM_PPN > 8 ? 8 : PBS_NUM_PPN))
	fi # !pbs
    fi # !thr_usr
fi # !mpi_flg

# Print initial state
if [ ${dbg_lvl} -ge 2 ]; then
    printf "dbg: a2o_flg  = ${a2o_flg}\n"
    printf "dbg: alg_opt  = ${alg_opt}\n"
    printf "dbg: att_flg  = ${att_flg}\n"
    printf "dbg: cln_flg  = ${cln_flg}\n"
    printf "dbg: d2f_flg  = ${d2f_flg}\n"
    printf "dbg: d2f_opt  = ${d2f_opt}\n"
    printf "dbg: dbg_lvl  = ${dbg_lvl}\n"
    printf "dbg: devnull  = ${devnull}\n"
    printf "dbg: dfl_lvl  = ${dfl_lvl}\n"
    printf "dbg: dpt_flg  = ${dpt_flg}\n"
    printf "dbg: dpt_fl   = ${dpt_fl}\n"
    printf "dbg: drc_in   = ${drc_in}\n"
    printf "dbg: drc_out  = ${drc_out}\n"
    printf "dbg: drc_tmp  = ${drc_tmp}\n"
    printf "dbg: dst_fl   = ${dst_fl}\n"
    printf "dbg: erwg_vrs = ${erwg_vrs_sng}\n"
    printf "dbg: esmf_typ = ${esmf_typ}\n"
    printf "dbg: fl_fmt   = ${fl_fmt}\n"
    printf "dbg: fl_in[0] = ${fl_in[0]}\n"
    printf "dbg: fl_nbr   = ${fl_nbr}\n"
    printf "dbg: flg_hrz  = ${flg_hrz}\n"
    printf "dbg: gaa_sng  = ${gaa_sng}\n"
    printf "dbg: gll_fl   = ${gll_fl}\n"
    printf "dbg: grd_dst  = ${grd_dst}\n"
    printf "dbg: grd_sng  = ${grd_sng}\n"
    printf "dbg: grd_src  = ${grd_src}\n"
    printf "dbg: inp_aut  = ${inp_aut}\n"
    printf "dbg: inp_glb  = ${inp_glb}\n"
    printf "dbg: inp_psn  = ${inp_psn}\n"
    printf "dbg: inp_std  = ${inp_std}\n"
    printf "dbg: hdr_pad  = ${hdr_pad}\n"
    printf "dbg: hrd_pth  = ${hrd_pth}\n"
    printf "dbg: hst_att  = ${hst_att}\n"
    printf "dbg: job_nbr  = ${job_nbr}\n"
    printf "dbg: in_fl    = ${in_fl}\n"
    printf "dbg: map_fl   = ${map_fl}\n"
    printf "dbg: map_mk   = ${map_mk}\n"
    printf "dbg: mbt_flg  = ${mbt_flg}\n"
    printf "dbg: mlt_map  = ${mlt_map_flg}\n"
    printf "dbg: mpi_flg  = ${mpi_flg}\n"
    printf "dbg: msh_fl   = ${msh_fl}\n"
    printf "dbg: msk_dst  = ${msk_dst}\n"
    printf "dbg: msk_out  = ${msk_out}\n"
    printf "dbg: msk_src  = ${msk_src}\n"
    printf "dbg: nco_opt  = ${nco_opt}\n"
    printf "dbg: nd_nbr   = ${nd_nbr}\n"
    printf "dbg: np_se_nbr= ${np_se_nbr}\n"
    printf "dbg: out_fl   = ${out_fl}\n"
    printf "dbg: par_typ  = ${par_typ}\n"
    printf "dbg: pdq_opt  = ${pdq_opt}\n"
    printf "dbg: ppc_prc  = ${ppc_prc}\n"
    printf "dbg: prs_stt  = ${prs_stt}\n"
#    printf "dbg: qea_flg  = ${qea_flg}\n"
    printf "dbg: rgr_opt  = ${rgr_opt}\n"
    printf "dbg: rnr_thr  = ${rnr_thr}\n"
    printf "dbg: rrg_bb   = ${bb_wesn}\n"
    printf "dbg: rrg_dat  = ${dat_glb}\n"
    printf "dbg: rrg_glb  = ${grd_glb}\n"
    printf "dbg: rrg_rgn  = ${grd_rgn}\n"
    printf "dbg: rrg_rnm  = ${rnm_sng}\n"
    printf "dbg: sgs_frc  = ${sgs_frc}\n"
    printf "dbg: sgs_msk  = ${sgs_msk}\n"
    printf "dbg: sgs_nrm  = ${sgs_nrm}\n"
    printf "dbg: skl_fl   = ${skl_fl}\n"
    printf "dbg: spt_pid  = ${spt_pid}\n"
    printf "dbg: std_chk  = ${std_chk}\n"
    printf "dbg: thr_nbr  = ${thr_nbr}\n"
    printf "dbg: ugrid_fl = ${ugrid_fl}\n"
    printf "dbg: uio_flg  = ${uio_flg}\n"
    printf "dbg: unq_sfx  = ${unq_sfx}\n"
    printf "dbg: var_lst  = ${var_lst}\n"
    printf "dbg: var_rgr  = ${var_rgr}\n"
    printf "dbg: vrt_fl   = ${vrt_fl}\n"
    printf "dbg: vrt_nm   = ${vrt_nm}\n"
    printf "dbg: vrt_opt  = ${vrt_opt}\n"
    printf "dbg: vrt_ntp  = ${vrt_ntp}\n"
    printf "dbg: vrt_xtr  = ${vrt_xtr}\n"
    printf "dbg: wgt_cmd  = ${wgt_cmd}\n"
    printf "dbg: wgt_opt  = ${wgt_opt}\n"
    printf "dbg: wgt_usr  = ${wgt_usr}\n"
    printf "dbg: xtr_nsp  = ${xtr_nsp}\n"
    printf "dbg: xtr_xpn  = ${xtr_xpn}\n"
    printf "dbg: Will regrid ${fl_nbr} files:\n"
    for ((fl_idx=0;fl_idx<${fl_nbr};fl_idx++)); do
	printf "${fl_in[${fl_idx}]}\n"
    done # !fl_idx
fi # !dbg
if [ ${dbg_lvl} -ge 2 ]; then
    if [ ${mpi_flg} = 'Yes' ]; then
	for ((nd_idx=0;nd_idx<${nd_nbr};nd_idx++)); do
	    printf "dbg: nd_nm[${nd_idx}] = ${nd_nm[${nd_idx}]}\n"
	done # !nd
    fi # !mpi
fi # !dbg
if [ ${dbg_lvl} -ge 2 ]; then
    psn_nbr=$#
    printf "dbg: Found ${psn_nbr} positional parameters (besides \$0):\n"
    for ((psn_idx=1;psn_idx<=psn_nbr;psn_idx++)); do
	printf "dbg: psn_arg[${psn_idx}] = ${!psn_idx}\n"
    done # !psn_idx
fi # !dbg

# Create output directories
if [ -n "${drc_out}" ] && [ ! -d "${drc_out}" ]; then 
    cmd_mkd="mkdir -p ${drc_out}"
    eval ${cmd_mkd}
    if [ "$?" -ne 0 ]; then
	printf "${spt_nm}: ERROR Failed to create output directory. Debug this:\n${cmd_mkd}\n"
	printf "${spt_nm}: HINT Creating a directory requires proper write permissions\n"
	exit 1
    fi # !err
fi # !drc_out
if [ -n "${drc_tmp}" ] && [ ! -d "${drc_tmp}" ]; then 
    cmd_mkd="mkdir -p ${drc_tmp}"
    eval ${cmd_mkd}
    if [ "$?" -ne 0 ]; then
	printf "${spt_nm}: ERROR Attempt to create temporary directory. Debug this:\n${cmd_mkd}\n"
	printf "${spt_nm}: HINT Creating a directory requires proper write permissions\n"
	exit 1
    fi # !err
fi # !drc_tmp

# Human-readable summary
date_srt=$(date +"%s")
if [ ${vrb_lvl} -ge ${vrb_4} ]; then
    printf "NCO regridder invoked with command:\n"
    echo "${cmd_ln}"
fi # !vrb_lvl
if [ -f 'PET0.RegridWeightGen.Log' ]; then
    if [ ${vrb_lvl} -ge ${vrb_4} ]; then
	printf "${spt_nm}: Removing PET0.RegridWeightGen.Log file and any other PET0.* files from current directory before running\n"
    fi # !vrb_lvl
    /bin/rm -f PET0.*
fi # !PETO
if [ ${vrb_lvl} -ge ${vrb_3} ]; then
    printf "Started processing at `date`.\n"
    printf "Running remap script ${spt_nm} from directory ${drc_spt}\n"
    printf "NCO binaries version ${nco_vrs} from directory ${drc_nco}\n"
    printf "Parallelism mode = ${par_typ}\n"
    if [ ${fl_nbr} -gt 1 ]; then
	if [ "${par_typ}" = ${par_bck} ]; then
	    printf "Background parallelism regridding files in fl_nbr/job_nbr = ${fl_nbr}/${job_nbr} = $((fl_nbr / job_nbr)) batches of job_nbr = ${job_nbr} files simultaneously using round-robin scheduling\n"
	elif [ "${par_typ}" = ${par_mpi} ]; then
	    printf "MPI parallelism dividing processing of ${fl_nbr} files onto nd_nbr = ${nd_nbr} nodes simultaneously using round-robin scheduling\n"
	else
	    printf "No parallelism--processes will be executed serially on a single node.\n"
	fi # !par_typ
    fi # !fl_nbr
    printf "Input files in or relative to directory ${drc_in}\n"
    printf "Intermediate/temporary files written to directory ${drc_tmp}\n"
    printf "Output files to directory ${drc_out}\n"
fi # !vrb_lvl
if [ "${map_mk}" != 'Yes' ] && [ "${map_usr_flg}" = 'Yes' ] && [ -n "${wgt_usr}" ]; then
    printf "${spt_nm}: ERROR Specifying both '-m map_fl' and '-w wgt_cmd' is only allowed when creating a map (weight-generator is superfluous when user supplies map)\n"
    exit 1
fi # wgt_usr
    
if [ "${dst_usr_flg}" = 'Yes' ]; then 
    if [ "${grd_dst_usr_flg}" = 'Yes' ]; then 
	printf "${spt_nm}: INFO Both '-d dst_fl' and '-g grd_dst' were specified so ${spt_nm} will infer ${grd_dst} from ${dst_fl}\n"
    fi # !grd_dst_usr_flg
fi # !dst_usr_flg
if [ "${dst_usr_flg}" != 'Yes' ] && [ "${grd_dst_usr_flg}" != 'Yes' ] && [ "${map_usr_flg}" != 'Yes' ] && [ "${grd_sng_usr_flg}" != 'Yes' ] && [ "${vrt_usr_flg}" != 'Yes' ]; then 
    printf "${spt_nm}: ERROR Unable to determine remapping procedure\nHINT: Specify the type of remapping to perform with at least one of the following options: 1) A data/template file, '-d dst_fl'; 2) A destination grid-file, '-g grd_dst'; 3) A grid-construction command, '-G grd_sng'; 4) A map-file with weights to apply, '-m map_fl'; 5) A vertical grid to interpolate to, --vrt_fl=vrt_fl\n"
    exit 1
fi # !dst_usr_flg
if [ "${dst_usr_flg}" != 'Yes' ] && [ "${grd_dst_usr_flg}" = 'Yes' ] && [ "${map_usr_flg}" != 'Yes' ] && [ "${grd_sng_usr_flg}" = 'Yes' ] && [ "${vrt_usr_flg}" != 'Yes' ]; then
    flg_grd_only='Yes'
fi # !flg_grd_only
if [ "${map_mk}" = 'Yes' ] || [ "${map_usr_flg}" = 'Yes' ]; then
    flg_hrz='Yes'
fi # !flg_hrz

# Generate destination grid, if necessary, once (only) before loop over input files
# Block 1: Destination grid
# Generate destination grid at most one-time (unlike source grid)
# Eventually we will allow destination grid to be provided as grid-file, map-file, or data-file without a switch
# Currently we require user to know (and specify) means by which destination grid is provided
if [ ${vrb_lvl} -ge ${vrb_3} ]; then
    if [ ${fl_nbr} -eq 0 ]; then
	printf "Map/grid-only run: no input data detected therefore will exit after generating map and/or grid\n"
    fi # !fl_nbr
    if [ -n "${pdq_opt}" ]; then 
	printf "Input data shaped in \"${prc_typ}\"-order, will first permute with \"ncpdq ${pdq_opt}\"\n"
    fi # !pdq_opt
    if [ "${d2f_flg}" = 'Yes' ]; then
	printf "Will convert all non-coordinate double precision input fields to single precision with \"ncpdq ${d2f_opt}\"\n"
    fi # !d2f_flg
    if [ "${prc_mpas}" = 'Yes' ]; then
	printf "MPAS input specified: will automatically renormalize (with --rnr=0.0) regridding\n"
	if [ "${clm_flg}" = 'No' ]; then
 	    printf "MPAS input specified: will automatically annotate NC_DOUBLE variables with _FillValue = ${mss_val} prior to regridding\n"
	fi # !clm_flg
	if [ "${dpt_flg}" = 'Yes' ]; then
 	    printf "MPAS input specified: will add depth coordinate to all 3D variables prior to regridding\n"
	fi # !dpt_flg
    fi # !mpas
    if [ "${prc_typ}" = 'sgs' ]; then 
	printf "Input assumed to contain sub-gridscale (SGS, aka \"fractional area\") data: Intensive values valid in gridcell for spatiotemporal fraction specified by \"${sgs_frc}\" variable, not for entire gridcell area and/or time-interval duration (except where ${sgs_frc} = 1.0). Will regrid ${sgs_frc}, and then normalize subsequent regridding to conserve ${sgs_frc}*gridcell_area*field_value (not gridcell_area*field_value). If re-normalization is also requested (with --rnr_thr option), then these values will be renormalizaed by ${sgs_frc} and will not be conservative.\n"
	if [ ${fl_nbr} -eq 0 ]; then
	    printf "${spt_nm}: ERROR Sub-gridscale handling currently requires at least one data file (for the surface fractions of each gridcell)\n"
	    echo "${spt_nm}: HINT Supply a data file with \"-i fl_in\""
	    exit 1
	fi # !fl_nbr
    fi # !sgs
fi # !vrb_lvl
if [ "${flg_hrz}" = 'Yes' ]; then
    if [ "${map_mk}" != 'Yes' ] && [ "${map_usr_flg}" = 'Yes' ]; then 
	if [ ${vrb_lvl} -ge ${vrb_3} ]; then
	    printf "Source and destination grids will both be read from supplied map-file\n"
	fi # !vrb_lvl
    else # !map_usr_flg
	fl_idx=0 # [idx] Current file index
	if [ "${dst_usr_flg}" = 'Yes' ]; then 
	    # Block 1 Loop 1: Generate, check, and store (but do not yet execute) commands
	    # Infer destination grid-file from data file
	    if [ ${vrb_lvl} -ge ${vrb_3} ]; then
		printf "Destination grid will be inferred from data-file\n"
	    fi # !vrb_lvl
	    cmd_dst[${fl_idx}]="ncks -O ${nco_opt} --rgr infer --rgr hnt_dst=\"${hnt_dst_fl}\" ${nco_dgn_area} ${nco_msk_dst} ${nco_var_rgr} ${nco_ugrid_fl} --rgr scrip=\"${grd_dst}\" \"${dst_fl}\" \"${tmp_out_fl}\""
	else # !dst_usr_flg
	    if [ "${grd_dst_usr_flg}" = 'Yes' ] && [ "${grd_sng_usr_flg}" != 'Yes' ]; then 
		if [ ${vrb_lvl} -ge ${vrb_3} ]; then
		    printf "Destination grid supplied by user\n"
		fi # !vrb_lvl
	    fi # !grd_dst_usr_flg
	    if [ "${grd_dst_usr_flg}" != 'Yes' ] && [ "${grd_sng_usr_flg}" != 'Yes' ]; then 
		printf "${spt_nm}: ERROR No destination grid specified with -g, inferral file specified with -d, or grid string specified with -G\n"
	    fi # !grd_dst_usr_flg
	    if [ "${grd_sng_usr_flg}" = 'Yes' ]; then
		# 20180903 Must quote grd_sng otherwise whitespace and shell redirection characters (e.g., in ttl argument) will confuse interpreter
		cmd_dst[${fl_idx}]="ncks -O --dmm_in_mk ${nco_opt} --rgr scrip=\"${grd_dst}\" ${nco_skl_fl} --rgr '${grd_sng}' \"${dmm_fl}\" \"${tmp_out_fl}\""
		if [ ${vrb_lvl} -ge ${vrb_3} ]; then
		    if [ "${grd_dst_usr_flg}" = 'Yes' ]; then
			printf "Destination grid will be generated in SCRIP format from NCO grid-formula ${grd_sng} and stored in ${grd_dst}\n"
		    else
			printf "Destination grid will be generated in SCRIP format from NCO grid-formula ${grd_sng} and stored in a temporary, internal location\n"
		    fi # !grd_sng_usr_flg
		fi # !vrb_lvl
	    fi # !grd_sng_usr_flg
	fi # !dst_usr_flg
	if [ "${dst_usr_flg}" = 'Yes' ] || [ "${grd_sng_usr_flg}" = 'Yes' ]; then 
	    # Block 1 Loop 2: Execute and/or echo commands
	    if [ ${dbg_lvl} -ge 1 ]; then
		echo ${cmd_dst[${fl_idx}]}
	    fi # !dbg
	    if [ ${dbg_lvl} -ne 2 ]; then
		eval ${cmd_dst[${fl_idx}]}
		if [ "$?" -ne 0 ]; then
		    if [ "${grd_sng_usr_flg}" = 'Yes' ]; then
			printf "${spt_nm}: ERROR Failed to generate grid from user-supplied grid-string. Debug this:\n${cmd_dst[${fl_idx}]}\n"
		    else # !grd_sng_usr_flg
			printf "${spt_nm}: ERROR Failed to infer destination grid. Debug this:\n${cmd_dst[${fl_idx}]}\n"
		    fi # !grd_sng_usr_flg
		    exit 1
		fi # !err
		if [ "${grd_sng_usr_flg}" = 'Yes' ]; then 
		    /bin/rm -f ${tmp_out_fl}
		fi # !grd_sng_usr_flg
	    fi # !dbg
	fi # !dst_usr_flg || grd_dst_usr_flg
	if [ ${vrb_lvl} -ge ${vrb_3} ] && [ ${flg_grd_only} != 'Yes' ]; then
	    printf "Weight-generation type: ${wgt_typ}\n"
	    printf "Algorithm selected to generate weights in map-file is: ${alg_opt}\n"
	    printf "Will generate mapping weights and map-file with \'${wgt_cmd}\'\n"
	fi # !vrb_lvl
	if [ ${flg_grd_only} != 'Yes' ]; then
	    command -v ${wgt_exe} 2>&1 > /dev/null || { printf "${spt_nm}: ERROR cannot find weight-generation command executable ${wgt_exe}. Please install the executable, or change your PATH to find it.\n${spt_nm}: HINT The Conda 'nco' package and some NCL packages provide ESMF_RegridWeightGen. Tempest executables can be installed from source (https://github.com/ClimateGlobalChange/tempestremap) or obtained via the Conda 'tempest-remap' package (which the Conda 'nco' package also automatically provides).\n"; exit 1; }
	fi # !flg_grd_only
	if [ ${vrb_lvl} -ge ${vrb_3} ]; then
	    if [ ${fl_nbr} -ge 2 ]; then 
		if [ "${mlt_map_flg}" = 'Yes' ]; then 
		    printf "Input files assumed to use unique input grids\nOne source grid-file will be inferred and one map-file generated per input file\n"
		else # !mlt_map_flg
		    printf "Input files assumed to use same input grid\nOnly one source grid-file and one map-file will be generated\n"
		fi # !mlt_map_flg
	    fi # !fl_nbr
	fi # !vrb_lvl
    fi # !map_usr
fi # !flg_hrz

if [ "${prc_typ}" = 'rrg' ]; then 
    fl_idx=0

    if [ -z "${rnm_sng}" ]; then 
	# Discern rename string from input file, assume dimension is 'ncol', strip whitespace
	rnm_sng=`ncks -m ${fl_in[${fl_idx}]} | cut -d ':' -f 1 | cut -d '=' -s -f 1 | grep ncol | sed 's/ncol//' | sed -e 's/^ *//' -e 's/ *$//'`
	rgn_nbr=`echo ${rnm_sng} | wc -l`
	if [ "${rgn_nbr}" -ne 1 ]; then
	    echo "ERROR: Inferred regional regridding suffix '${rnm_sng}' indicates multiple regions present in input file. ncremap only works on one region at a time."
	    echo "HINT: Provide a single region string as the argument to the --rrg_rnm_sng option"
	    exit 1
	fi # !rgn_nbr
	echo "${spt_nm}: INFO Parsed input file dimension list to obtain regional suffix string '${rnm_sng}'"
    fi # !rnm_sng
    if [ -n "${rnm_sng}" ]; then 
	if [ -n "${bb_wesn}" ]; then 
	    echo "${spt_nm}: INFO Will use explicitly specified comma-separated rectangular WESN bounding box string ${bb_west} instead of parsing string suffix ${rnm_sng}."
	else # !bb_wesn
	    rnm_rx='^_(.*)_to_(.*)_(.*)_to_(.*)$'
	    if [[ "${rnm_sng}" =~ ${rnm_rx} ]]; then
		lon1=${BASH_REMATCH[1]%?}
		lon2=${BASH_REMATCH[2]%?}
		if [ "${BASH_REMATCH[1]: -1}" = 'w' ]; then
		    let lon1=360-${lon1}
		fi # !w
		if [ "${BASH_REMATCH[2]: -1}" = 'w' ]; then
		    let lon2=360-${lon2}
		fi # !w
		if [ ${lon1} -lt ${lon2} ]; then
		    lon_min=${lon1}
		    lon_max=${lon2}
		else
		    lon_min=${lon2}
		    lon_max=${lon1}
		fi # !lon1
		lat1=${BASH_REMATCH[3]%?}
		lat2=${BASH_REMATCH[4]%?}
		if [ "${BASH_REMATCH[3]: -1}" = 's' ]; then
		    let lat1=-${lat1}
		fi # !w
		if [ "${BASH_REMATCH[4]: -1}" = 's' ]; then
		    let lat2=-${lat2}
		fi # !w
		if [ ${lat1} -lt ${lat2} ]; then
		    lat_min=${lat1}
		    lat_max=${lat2}
		else
		    lat_min=${lat2}
		    lat_max=${lat1}
		fi # !lat1
	    else # !rnm_sng
		echo "ERROR: Regional regridding suffix string '${rnm_sng}' does not match regular expression '${rnm_rx}'"
		echo "HINT: Regional regridding suffix string must have form like '_128e_to_134e_9s_to_16s' or '_20w_to_20e_10s_to_10n'"
		exit 1
	    fi # !rnm_sng
	    bb_wesn="${lon_min},${lon_max},${lat_min},${lat_max}"
	    echo "${spt_nm}: INFO Parsed suffix string ${rnm_sng} to obtain comma-separated rectangular WESN bounding box string ${bb_wesn}"
	fi # !bb_wesn
    else
	echo "${spt_nm}: ERROR Regional regridding requires string suffix appended to variables in regional data file to be specified with --rrg_rnm_sng argument"
	exit 1
    fi # !rnm_sng

    if [ ${vrb_lvl} -ge ${vrb_3} ]; then
	printf "Input assumed to be EAM/CAM-SE format regional data to regrid (aka RRG). RRG data are usually produced by explicitly requesting (sometimes multiple) regions from EAM/CAM-SE models with the \"finclNlonlat\" namelist variable. Will infer SCRIP-format regional source grid by cutting vertice information (originally from global dual-grid file ${grd_glb}) from rectangular WESN bounding box \"${bb_wesn}\" of identity-remapped (and thus vertice-annotated) copy of global data file ${dat_glb}. Will then create single map-file to regrid copy of requested fields with \"${rnm_sng}\" removed from dimension and variable names.\n"
    fi # !vrb_lvl

    if [ ${vrb_lvl} -ge ${vrb_3} ]; then
	printf "RRG: Identity-remap global data file from/to dual-grid to annotate it with vertices...\n"
    fi # !vrb_lvl
    cmd_nnt[${fl_idx}]="ncremap --vrb=0 -a bilin -s \"${grd_glb}\" -g \"${grd_glb}\" \"${dat_glb}\" \"${nnt_fl}\""
    if [ ${dbg_lvl} -ge 1 ]; then
	echo ${cmd_nnt[${fl_idx}]}
    fi # !dbg
    if [ ${dbg_lvl} -ne 2 ]; then
	eval ${cmd_nnt[${fl_idx}]}
	if [ "$?" -ne 0 ]; then
	    printf "${spt_nm}: ERROR Failed to identity-remap to annotate global data file. Debug this:\n${cmd_nnt[${fl_idx}]}\n"
	    exit 1
	fi # !err
    fi # !dbg

    if [ ${vrb_lvl} -ge ${vrb_3} ]; then
	printf "RRG: Subset coordinates to rectangular WESN regional bounding box ${bb_wesn}...\n"
    fi # !vrb_lvl
    cmd_sbs[${fl_idx}]="ncks -O -v lat,lon -X ${bb_wesn} \"${nnt_fl}\" \"${rgn_fl}\""
    if [ ${dbg_lvl} -ge 1 ]; then
	echo ${cmd_sbs[${fl_idx}]}
    fi # !dbg
    if [ ${dbg_lvl} -ne 2 ]; then
	eval ${cmd_sbs[${fl_idx}]}
	if [ "$?" -ne 0 ]; then
	    printf "${spt_nm}: ERROR Failed to subset and hyperslab coordinates into regional file. Debug this:\n${cmd_sbs[${fl_idx}]}\n"
	    exit 1
	fi # !err
    fi # !dbg

    if [ ${vrb_lvl} -ge ${vrb_3} ]; then
	printf "RRG: Infer source grid from subsetted, annotated, regional coordinate file...\n"
    fi # !vrb_lvl
    cmd_nfr[${fl_idx}]="ncks -O ${nco_opt} --rgr infer --rgr hnt_src=\"${hnt_src_fl}\" ${nco_msk_src} ${nco_var_rgr} --rgr scrip=\"${grd_src}\" \"${rgn_fl}\" \"${tmp_out_fl}\""
    if [ ${dbg_lvl} -ge 1 ]; then
	echo ${cmd_nfr[${fl_idx}]}
    fi # !dbg
    if [ ${dbg_lvl} -ne 2 ]; then
	eval ${cmd_nfr[${fl_idx}]}
	if [ "$?" -ne 0 ]; then
	    printf "${spt_nm}: ERROR Failed to infer source grid from subsetted, annotated, regional coordinate file. Debug this:\n${cmd_nfr[${fl_idx}]}\n"
	    exit 1
	fi # !err
    fi # !dbg
fi # !rrg

# If user provides source gridfile, or it was inferred in RRG or SGS modes, assume it applies to every input file
# Do not infer source gridfiles from input files within file loop
# Generate map-file once outside of file loop, and re-use it for every input file
if [ "${grd_src_usr_flg}" = 'Yes' ] || [ "${prc_typ}" = 'rrg' ]; then
    if [ ${vrb_lvl} -ge ${vrb_3} ]; then
	printf "Source grid supplied by user (or derived from RRG procedure) as ${grd_src}\n"
    fi # !vrb_lvl
    fl_idx=0
    if [ ${vrb_lvl} -ge ${vrb_1} ]; then
	printf "Grid(src): ${grd_src}\n"
	printf "Grid(dst): ${grd_dst}\n"
    fi # !vrb_lvl
    if [ "${wgt_typ}" = 'esmf' ]; then 
	rgn_opt=''
	if [ -n "${hnt_src}" ]; then
	    rgn_opt="${rgn_opt} ${hnt_src}"
	elif [ -f "${hnt_src_fl}" ]; then
	    rgn_opt="${rgn_opt} `cat ${hnt_src_fl}`"
	fi # !hnt_src_fl
	if [ -n "${hnt_dst}" ]; then
	    rgn_opt="${rgn_opt} ${hnt_dst}"
	elif [ -f "${hnt_dst_fl}" ]; then
	    rgn_opt="${rgn_opt} `cat ${hnt_dst_fl}`"
	fi # !hnt_dst_fl
	cmd_map[${fl_idx}]="${wgt_cmd} -s \"${grd_src}\" -d \"${grd_dst}\" -w \"${map_fl}\" --method ${alg_opt} ${wgt_opt} ${rgn_opt}${devnull}"
    elif [ "${wgt_typ}" = 'nco' ]; then 
	cmd_map[${fl_idx}]="${wgt_cmd} ${wgt_opt} --wgt_typ=${alg_opt} --thr_nbr=${thr_nbr} ${nco_opt} --grd_src=\"${grd_src}\" --grd_dst=\"${grd_dst}\" --map_fl=\"${map_fl}\" ${msh_opt} ${rgr_opt} \"${dmm_fl}\" \"${tmp_out_fl}\"${devnull}"
    elif [ "${wgt_typ}" = 'tempest' ]; then 
	cmd_msh[${fl_idx}]="GenerateOverlapMesh ${msh_opt_tps} --a \"${grd_src}\" --b \"${grd_dst}\" --out \"${msh_fl}\"${devnull}"
	if [ "${a2o_flg}" = 'Yes' ]; then 
	    cmd_msh[${fl_idx}]="GenerateOverlapMesh ${msh_opt_tps} --b \"${grd_src}\" --a \"${grd_dst}\" --out \"${msh_fl}\"${devnull}"
	fi # !a2o_flg
	cmd_map[${fl_idx}]="${wgt_cmd} --in_mesh \"${grd_src}\" --out_mesh \"${grd_dst}\" --ov_mesh \"${msh_fl}\" --out_map \"${map_fl}\" ${wgt_opt}${devnull}"
	if [ "${trn_map}" = 'Yes' ]; then 
	    # NB: Generate mono map for opposite direction regridding (i.e., reverse switches and grids), then transpose
	    cmd_map[${fl_idx}]="${wgt_cmd} --in_mesh \"${grd_dst}\" --out_mesh \"${grd_src}\" --ov_mesh \"${msh_fl}\" --out_map \"${map_trn_fl}\" ${wgt_opt}${devnull}"
	    cmd_trn[${fl_idx}]="GenerateTransposeMap --in \"${map_trn_fl}\" --out \"${map_fl}\"${devnull}"
	fi # !trn_map
	if [ ${dbg_lvl} -ge 1 ]; then
	    echo ${cmd_msh[${fl_idx}]}
	fi # !dbg
	if [ ${dbg_lvl} -ne 2 ]; then
	    eval ${cmd_msh[${fl_idx}]}
	    if [ "$?" -ne 0 ] || [ ! -f ${msh_fl} ]; then
		printf "${spt_nm}: ERROR Failed to generate intersection mesh-file. Debug this:\n${cmd_msh[${fl_idx}]}\n"
		printf "${spt_nm}: HINT GenerateOverlapMesh can fail for a number of reasons including 1) It requires that grids of unequal area be given as arguments in the order smaller first, larger second. ncremap supplies the grid arguments in the order source first, destination second unless explicitly told otherwise. A source grid that is a superset of the destination would violate the GenerateOverlapMesh rule. The solution is to add the \"--a2o\" switch (documented at http://nco.sf.net/nco.html#a2o) that tells ncremap to swap the grid argument order. 2) It requires that SCRIP files strictly adhere to SCRIP conventions, including that \"grid_imask\" be of integer type not floating-point type. Unfortunately some malformed SCRIP files violate this convention. The workaround can be as simple as \"ncap2 -s 'grid_imask=int(grid_imask)' grid_in.nc grid_out.nc\n"
		exit 1
	    fi # !err
	fi # !dbg
    fi # !wgt_typ
    if [ ${dbg_lvl} -ge 1 ]; then
	echo ${cmd_map[${fl_idx}]}
    fi # !dbg
    if [ ${dbg_lvl} -ne 2 ]; then
	eval ${cmd_map[${fl_idx}]}
	if [ "$?" -ne 0 ] || [ ! -f ${map_rsl_fl} ]; then
	    printf "${spt_nm}: ERROR Failed to generate map-file. Debug this:\n${cmd_map[${fl_idx}]}\n"
	    if [ "${wgt_typ}" = 'esmf' ]; then 
		printf "${spt_nm}: HINT When ESMF fails to generate map-files, it often puts additional debugging information in the file named PET0.RegridWeightGen.Log in the invocation directory (${drc_pwd})\n"
	    fi # !esmf
	    exit 1
	fi # !err
    fi # !dbg
    # 20181116: GenerateTransposeMap does not propagate global attributes from input map
    # Moreover, it does not generate any metadata of its own except "Title"
    # Hence monotr maps are naked of usual Tempest map metadata
    if [ "${trn_map}" = 'Yes' ]; then 
	if [ ${dbg_lvl} -ge 1 ]; then
	    echo ${cmd_trn[${fl_idx}]}
	fi # !dbg
	if [ ${dbg_lvl} -ne 2 ]; then
	    eval ${cmd_trn[${fl_idx}]}
	    if [ "$?" -ne 0 ] || [ ! -f ${map_fl} ]; then
		printf "${spt_nm}: ERROR Failed to transpose map-file. Debug this:\n${cmd_trn[${fl_idx}]}\n"
		exit 1
	    fi # !err
	fi # !dbg
    fi # !trn_map
    if [ "${map_usr_flg}" = 'Yes' ]; then
	hst_att="`date`: ${cmd_ln}; ${cmd_map[${fl_idx}]}"
	if [ "${wgt_typ}" = 'tempest' ]; then 
	    hst_att="`date`: ${cmd_ln}; ${cmd_msh[${fl_idx}]}; ${cmd_map[${fl_idx}]}"
	    if [ "${trn_map}" = 'Yes' ]; then 
		hst_att="${hst_att}; ${cmd_trn[${fl_idx}]}"
	    fi # !trn_map
	fi # !tempest
	cmd_att[${fl_idx}]="ncatted -O ${gaa_sng} --gaa history='${hst_att}' \"${map_fl}\""
	if [ ${dbg_lvl} -ge 1 ]; then
	    echo ${cmd_att[${fl_idx}]}
	fi # !dbg
	if [ ${dbg_lvl} -ne 2 ]; then
	    eval ${cmd_att[${fl_idx}]}
	    if [ "$?" -ne 0 ] || [ ! -f ${map_fl} ]; then
		printf "${spt_nm}: ERROR Failed to annotate map-file. Debug this:\n${cmd_att[${fl_idx}]}\n"
		exit 1
	    fi # !err
	fi # !dbg
    fi # !map_usr_flg
    # Set map_mk to something besides 'Yes' to avoid re-generating map within file loop
    map_mk='Already made map once. Never again!'
fi # !grd_src_usr_flg

# Begin loop over input files
let bch_nbr=$((fl_nbr / job_nbr))
let bch_flg=$((fl_nbr % job_nbr))
if [ ${fl_nbr} -gt 0 ] && [ ${bch_nbr} -eq 0 ]; then
    let bch_nbr=$((bch_nbr+1))
elif [ ${bch_flg} -ne 0 ]; then
    let bch_nbr=$((bch_nbr+1))
fi # !bch_flg
let bch_nbrm1=$((bch_nbr-1))
for ((bch_idx=0;bch_idx<bch_nbr;bch_idx++)); do
    # fl_idx is 0-based, bch_idx is 0-based
    let fl_idx_srt=$((bch_idx * job_nbr))
    let fl_idx_end=$((fl_idx_srt + job_nbr - 1))
    if [ ${bch_idx} -eq ${bch_nbrm1} ] && [ ${bch_flg} -ne 0 ] ; then
	let fl_idx_srt=$((bch_idx * job_nbr))
	let fl_idx_end=$((fl_nbr - 1))
    fi # !bch_flg
    for ((fl_idx=fl_idx_srt;fl_idx<=fl_idx_end;fl_idx++)); do
	in_fl=${fl_in[${fl_idx}]}
	if [ "$(basename "${in_fl}")" = "${in_fl}" ]; then
	    in_fl="${drc_pwd}/${in_fl}"
	fi # !basename
	idx_prn=`printf "%02d" ${fl_idx}`
	if [ ${vrb_lvl} -ge ${vrb_1} ]; then
	    printf "Input #${idx_prn}: ${in_fl}\n"
	fi # !vrb_lvl
	if [ "${out_usr_flg}" = 'Yes' ]; then 
	    if [ ${fl_nbr} -ge 2 ]; then 
		echo "ERROR: Single output filename specified with -o for multiple input files"
		echo "HINT: For multiple input files use -O option to specify output directory and do not use -o or second positional option. Output files will have same name as input files, but will be in different directory."
		exit 1
	    fi # !fl_nbr
	    if [ -n "${drc_usr}" ]; then
		out_fl="${drc_out}/${out_fl}"
	    fi # !drc_usr
	else # !out_usr_flg
	    out_fl="${drc_out}/$(basename "${in_fl}")"
	fi # !out_fl
	if [ "${in_fl}" = "${out_fl}" ]; then
	    echo "ERROR: Input file = Output file = ${in_fl}"
	    echo "HINT: To prevent inadvertent data loss, ${spt_nm} insists that Input file and Output filenames differ"
	    exit 1
	fi # !basename
	fl_in[${fl_idx}]=${in_fl}
	fl_out[${fl_idx}]=${out_fl}

	# Temporary files that need fl_idx granularity
	if [ -n "${unq_sfx}" ]; then
	    unq_sfx_grn="${unq_sfx}.flidx${fl_idx}"
	fi # !unq_sfx
	att_fl[${fl_idx}]="${drc_tmp}/ncremap_tmp_att.nc${unq_sfx_grn}" # [sng] Missing value workflow (MPAS) default
	d2f_fl[${fl_idx}]="${drc_tmp}/ncremap_tmp_d2f.nc${unq_sfx_grn}" # [sng] File with doubles converted to float
	dpt_tmp_fl[${fl_idx}]="${drc_tmp}/ncremap_tmp_dpt.nc${unq_sfx_grn}" # [sng] File with depth coordinate added
	pdq_fl[${fl_idx}]="${drc_tmp}/ncremap_tmp_pdq.nc${unq_sfx_grn}" # [sng] Permuted/Unpacked data default (AIRS, HIRDLS, MLS, MOD04, MPAS)
	rnm_fl[${fl_idx}]="${drc_tmp}/ncremap_tmp_rnm.nc${unq_sfx_grn}" # [sng] Renamed regional (RRG) default

	# Generate new map unless map-file was supplied or already-generated
	# Multiple maps can be generated only if mlt_map_flg=Yes (temporarily borken 20190920)
	# NB: RRG infers source grid outside file loop, and forbids multiple source grids
	# RRG produces map before file loop, and will not make maps inside file loop
	if [ "${map_mk}" = 'Yes' ] && [ "${fl_idx}" -eq 0 ]; then
	    
	    # Block 1: Special cases
	    if [ "${prc_typ}" = 'hirdls' ] || [ "${prc_typ}" = 'mls' ]; then
		# Pre-process zonal input files so grid inferral works
		# 20160214: fix record variable to work around ncpdq problem
		cmd_znl[${fl_idx}]="ncecat -O -u lon ${nco_opt} ${nco_var_lst} \"${in_fl}\" \"${in_fl}\" \"${in_fl}\" \"${in_fl}\" \"${znl_fl/znl/znl1}\";ncap2 -O ${nco_opt} -s 'lon[\$lon]={0.0,90.0,180.0,270.0}' \"${znl_fl/znl/znl1}\" \"${znl_fl/znl/znl2}\""
		in_fl="${znl_fl/znl/znl2}"
		if [ ${dbg_lvl} -ge 1 ]; then
		    echo ${cmd_znl[${fl_idx}]}
		fi # !dbg
		if [ ${dbg_lvl} -ne 2 ]; then
		    eval ${cmd_znl[${fl_idx}]}
		    if [ "$?" -ne 0 ] || [ ! -f "${znl_fl/znl/znl2}" ]; then
			printf "${spt_nm}: ERROR Failed to generate lat-lon file from zonal file. Debug this:\n${cmd_znl[${fl_idx}]}\n"
			exit 1
		    fi # !err
		fi # !dbg
	    fi # !znl
	    
	    # Block 2: Source grid
	    # Block 2 Loop 1: Source gridfile command
	    if [ ! -f "${in_fl}" ]; then
		echo "${spt_nm}: ERROR Unable to find input file ${in_fl}"
		echo "HINT: All files implied to exist must be in the directory specified by their filename or in ${drc_in} before ${spt_nm} will proceed"
		exit 1
	    fi # ! -f
	    # Infer source grid-file from input data file
	    cmd_src[${fl_idx}]="ncks -O ${nco_opt} --rgr infer --rgr hnt_src=\"${hnt_src_fl}\" ${nco_msk_src} ${nco_ugrid_fl} ${nco_var_rgr} --rgr scrip=\"${grd_src}\" \"${in_fl}\" \"${tmp_out_fl}\""
	
	    # Block 2 Loop 2: Execute and/or echo commands
	    if [ ${dbg_lvl} -ge 1 ]; then
		echo ${cmd_src[${fl_idx}]}
	    fi # !dbg
	    if [ ${dbg_lvl} -ne 2 ]; then
		eval ${cmd_src[${fl_idx}]}
		if [ "$?" -ne 0 ]; then
		    printf "${spt_nm}: ERROR Failed to infer source grid. Debug this:\n${cmd_src[${fl_idx}]}\n"
		    exit 1
		fi # !err
	    fi # !dbg
	    
	    # Block 3: Source->destination maps
	    # Block 3 Loop 1: Map-file commands
	    if [ ${vrb_lvl} -ge ${vrb_1} ]; then
		printf "Grid(src): ${grd_src}\n"
		printf "Grid(dst): ${grd_dst}\n"
	    fi # !vrb_lvl
	    if [ "${wgt_typ}" = 'esmf' ]; then 
		rgn_opt=''
		if [ -n "${hnt_src}" ]; then
		    rgn_opt="${rgn_opt} ${hnt_src}"
		elif [ -f "${hnt_src_fl}" ]; then
		    rgn_opt="${rgn_opt} `cat ${hnt_src_fl}`"
		fi # !hnt_src_fl
		if [ -n "${hnt_dst}" ]; then
		    rgn_opt="${rgn_opt} ${hnt_dst}"
		elif [ -f "${hnt_dst_fl}" ]; then
		    rgn_opt="${rgn_opt} `cat ${hnt_dst_fl}`"
		fi # !hnt_dst_fl
		cmd_map[${fl_idx}]="${wgt_cmd} -s \"${grd_src}\" -d \"${grd_dst}\" -w \"${map_fl}\" --method ${alg_opt} ${wgt_opt} ${rgn_opt}${devnull}"
	    elif [ "${wgt_typ}" = 'nco' ]; then 
		if [ ${vrb_lvl} -ge ${vrb_1} ]; then
		    if [ -n "${msh_opt}" ]; then
			printf "Mesh-File: ${msh_fl}\n"
		    fi # !msh_opt
		fi # !vrb_lvl
		cmd_map[${fl_idx}]="${wgt_cmd} ${wgt_opt} --wgt_typ=${alg_opt} --thr_nbr=${thr_nbr} ${nco_opt} --grd_src=\"${grd_src}\" --grd_dst=\"${grd_dst}\" --map_fl=\"${map_fl}\" ${msh_opt} ${rgr_opt} \"${dmm_fl}\" \"${tmp_out_fl}\"${devnull}"
	    elif [ "${wgt_typ}" = 'tempest' ]; then 
		if [ ${vrb_lvl} -ge ${vrb_1} ]; then
		    printf "Mesh-File: ${msh_fl}\n"
		fi # !vrb_lvl
		cmd_msh[${fl_idx}]="GenerateOverlapMesh ${msh_opt_tps} --a \"${grd_src}\" --b \"${grd_dst}\" --out \"${msh_fl}\"${devnull}"
		if [ "${a2o_flg}" = 'Yes' ]; then 
		    cmd_msh[${fl_idx}]="GenerateOverlapMesh ${msh_opt_tps} --b \"${grd_src}\" --a \"${grd_dst}\" --out \"${msh_fl}\"${devnull}"
		fi # !a2o_flg
		cmd_map[${fl_idx}]="${wgt_cmd} --in_mesh \"${grd_src}\" --out_mesh \"${grd_dst}\" --ov_mesh \"${msh_fl}\" --out_map \"${map_fl}\" ${wgt_opt}${devnull}"
		if [ "${trn_map}" = 'Yes' ]; then 
		    # NB: Generate mono map for opposite direction regridding (i.e., reverse switches and grids), then transpose
		    cmd_map[${fl_idx}]="${wgt_cmd} --in_mesh \"${grd_dst}\" --out_mesh \"${grd_src}\" --ov_mesh \"${msh_fl}\" --out_map \"${map_trn_fl}\" ${wgt_opt}${devnull}"
		    cmd_trn[${fl_idx}]="GenerateTransposeMap --in \"${map_trn_fl}\" --out \"${map_fl}\"${devnull}"
		fi # !trn_map
		if [ ${dbg_lvl} -ge 1 ]; then
		    echo ${cmd_msh[${fl_idx}]}
		fi # !dbg
		if [ ${dbg_lvl} -ne 2 ]; then
		    eval ${cmd_msh[${fl_idx}]}
		    if [ "$?" -ne 0 ] || [ ! -f ${msh_fl} ]; then
			printf "${spt_nm}: ERROR Failed to generate intersection mesh-file. Debug this:\n${cmd_msh[${fl_idx}]}\n"
			printf "${spt_nm}: HINT GenerateOverlapMesh requires that grids of unequal area be given as arguments in the order smaller first, larger second. ncremap supplies the grid arguments in the order source first, destination second unless explicitly told otherwise. A source grid that is a superset of the destination would violate the GenerateOverlapMesh rule. The solution is to add the \"--a2o\" switch (documented at http://nco.sf.net/nco.html#a2o) that tells ncremap to swap the grid argument order.\n"
			exit 1
		    fi # !err
		fi # !dbg
	    fi # !wgt_typ
	    
	    # Block 3 Loop 2: Execute and/or echo commands
	    if [ ${dbg_lvl} -ge 1 ]; then
		echo ${cmd_map[${fl_idx}]}
	    fi # !dbg
	    if [ ${dbg_lvl} -ne 2 ]; then
		eval ${cmd_map[${fl_idx}]}
		if [ "$?" -ne 0 ] || [ ! -f ${map_rsl_fl} ]; then
		    printf "${spt_nm}: ERROR Failed to generate map-file. Debug this:\n${cmd_map[${fl_idx}]}\n"
		    if [ "${wgt_typ}" = 'esmf' ]; then 
			printf "${spt_nm}: HINT When ESMF fails to generate map-files, it often puts additional debugging information in the file named PET0.RegridWeightGen.Log in the invocation directory (${drc_pwd})\n"
		    fi # !esmf
		    exit 1
		fi # !err
		if [ "${map_usr_flg}" = 'Yes' ]; then
		    hst_att="`date`: ${cmd_ln}; ${cmd_map[${fl_idx}]}"
		    cmd_att[${fl_idx}]="ncatted -O ${gaa_sng} --gaa history='${hst_att}' \"${map_rsl_fl}\""
		    eval ${cmd_att[${fl_idx}]}
		if [ "$?" -ne 0 ]; then
		    printf "${spt_nm}: ERROR Failed to annotate map-file. Debug this:\n${cmd_att[${fl_idx}]}\n"
		    exit 1
		fi # !err
		fi # !map_usr_flg
	    fi # !dbg
	    if [ "${trn_map}" = 'Yes' ]; then 
		if [ ${dbg_lvl} -ge 1 ]; then
		    echo ${cmd_trn[${fl_idx}]}
		fi # !dbg
		if [ ${dbg_lvl} -ne 2 ]; then
		    eval ${cmd_trn[${fl_idx}]}
		    if [ "$?" -ne 0 ] || [ ! -f ${map_fl} ]; then
			printf "${spt_nm}: ERROR Failed to transpose map-file. Debug this:\n${cmd_trn[${fl_idx}]}\n"
			exit 1
		    fi # !err
		fi # !dbg
	    fi # !trn_map
	    
	    # Prevent creating new source gridfile and map-file after first iteration
	    if [ "${mlt_map_flg}" = 'No' ] && [ ${fl_idx} -eq 0 ]; then 
		map_mk='Already made map once. Never again.'
	    fi # !mlt_map_flg
	    
	fi # !map_mk
    done # !fl_idx
	
    # 20190920: Nothing to wait() for here since we produce only one map
    
    # Block 4: Special cases
    if [ "${dpt_flg}" = 'Yes' ]; then
	# Block 4a: Add MPAS depth coordinate (prior to permutation)
	for ((fl_idx=fl_idx_srt;fl_idx<=fl_idx_end;fl_idx++)); do
	    if [ ${vrb_lvl} -ge ${vrb_2} ]; then
		printf "DPT(in)  : ${fl_in[${fl_idx}]}\n"
		printf "DPT(out) : ${dpt_tmp_fl[${fl_idx}]}\n"
	    fi # !vrb_lvl
	    cmd_dpt[${fl_idx}]="${cmd_mpi[${fl_idx}]} ${cmd_dpt_mpas} ${cmd_dpt_opt} -i \"${fl_in[${fl_idx}]}\" -o \"${dpt_tmp_fl[${fl_idx}]}\""
	    ${fl_in[${fl_idx}]}=${dpt_tmp_fl[${fl_idx}]}
	    if [ ${dbg_lvl} -ge 1 ]; then
		echo ${cmd_dpt[${fl_idx}]}
	    fi # !dbg
	    if [ ${dbg_lvl} -ne 2 ]; then
		if [ -z "${par_opt}" ]; then
		    eval ${cmd_dpt[${fl_idx}]}
		    if [ "$?" -ne 0 ] || [ ! -f ${dpt_tmp_fl[${fl_idx}]} ]; then
			printf "${spt_nm}: ERROR Failed to add depth coordinate to MPAS file. Debug this:\n${cmd_dpt[${fl_idx}]}\nHINTS: 1) Verify that ${dpt_exe_mpas} is executable from the command-line, it requires Python and the xarray package to succeed. 2) Verify that ${dpt_fl} or ${fl_in[${fl_idx}]} contains variable \"refBottomDepth\".\n"
			exit 1
		    fi # !err
		else # !par_typ
		    eval ${cmd_dpt[${fl_idx}]} ${par_opt}
		    dpt_pid[${fl_idx}]=$!
		fi # !par_typ
	    fi # !dbg
	done # !fl_idx
	
	# Parallel regridding (both Background and MPI) spawns simultaneous processes in batches of ${job_nbr}
	# Once ${job_nbr} jobs are running, wait() for all to finish before issuing another batch
	# Following wait() blocks are identical except for error message and this comment is omitted
	if [ -n "${par_opt}" ]; then
	    for ((fl_idx=fl_idx_srt;fl_idx<=fl_idx_end;fl_idx++)); do
		wait ${dpt_pid[${fl_idx}]}
		if [ "$?" -ne 0 ] || [ ! -f ${dpt_tmp_fl[${fl_idx}]} ]; then
		    printf "${spt_nm}: ERROR Failed to add depth coordinate to MPAS file. Debug this:\n${cmd_dpt[${fl_idx}]}\nHINTS: 1) Verify that ${dpt_exe_mpas} is executable from the command-line, it requires Python and the xarray package to succeed. 2) Verify that ${dpt_fl} or ${fl_in[${fl_idx}]} contains variable \"refBottomDepth\".\n"
		    exit 1
		fi # !err
	    done # !fl_idx
	fi # !par_opt
    fi # !dpt_flg

    if [ -n "${pdq_opt}" ]; then
	# Block 4b: Generic Permutation/Unpacking (AIRS, HIRDLS, MLS, MOD04, MPAS)
	# Do sub-setting operation (like PDQ) first so cmd_att works on smaller, sub-set files
	for ((fl_idx=fl_idx_srt;fl_idx<=fl_idx_end;fl_idx++)); do
	    if [ ${vrb_lvl} -ge ${vrb_2} ]; then
		printf "PDQ(in)  : ${fl_in[${fl_idx}]}\n"
		printf "PDQ(out) : ${pdq_fl[${fl_idx}]}\n"
	    fi # !vrb_lvl
	    cmd_pdq[${fl_idx}]="${cmd_mpi[${fl_idx}]} ncpdq -O ${nco_opt} ${nco_var_lst} ${pdq_opt} \"${fl_in[${fl_idx}]}\" \"${pdq_fl[${fl_idx}]}\""
	    fl_in[${fl_idx}]=${pdq_fl[${fl_idx}]}
	    if [ ${dbg_lvl} -ge 1 ]; then
		echo ${cmd_pdq[${fl_idx}]}
	    fi # !dbg
	    if [ ${dbg_lvl} -ne 2 ]; then
		if [ -z "${par_opt}" ]; then
		    eval ${cmd_pdq[${fl_idx}]}
		    if [ "$?" -ne 0 ] || [ ! -f ${pdq_fl[${fl_idx}]} ]; then
			printf "${spt_nm}: ERROR Failed to generate pdq-file. Debug this:\n${cmd_pdq[${fl_idx}]}\n"
			exit 1
		    fi # !err
		else # !par_typ
		    eval ${cmd_pdq[${fl_idx}]} ${par_opt}
		    pdq_pid[${fl_idx}]=$!
		fi # !par_typ
	    fi # !dbg
	done # !fl_idx

	if [ -n "${par_opt}" ]; then
	    for ((fl_idx=fl_idx_srt;fl_idx<=fl_idx_end;fl_idx++)); do
		wait ${pdq_pid[${fl_idx}]}
		if [ "$?" -ne 0 ] || [ ! -f ${pdq_fl[${fl_idx}]} ]; then
		    printf "${spt_nm}: ERROR Failed to generate pdq-file. Debug this:\n${cmd_pdq[${fl_idx}]}\n"
		    exit 1
		fi # !err
	    done # !fl_idx
	fi # !par_opt
    fi # !pdq_opt
	
    if [ "${d2f_flg}" = 'Yes' ]; then
	# Block 4c: Double->Float conversion (by-request and possibly default for MPAS)
	for ((fl_idx=fl_idx_srt;fl_idx<=fl_idx_end;fl_idx++)); do
	    if [ ${vrb_lvl} -ge ${vrb_2} ]; then
		printf "D2F(in)  : ${fl_in[${fl_idx}]}\n"
		printf "D2F(out) : ${d2f_fl[${fl_idx}]}\n"
	    fi # !vrb_lvl
	    cmd_d2f[${fl_idx}]="${cmd_mpi[${fl_idx}]} ncpdq -O ${nco_opt} ${nco_var_lst} ${d2f_opt} \"${fl_in[${fl_idx}]}\" \"${d2f_fl[${fl_idx}]}\""
	    fl_in[${fl_idx}]=${d2f_fl[${fl_idx}]}
	    if [ ${dbg_lvl} -ge 1 ]; then
		echo ${cmd_d2f[${fl_idx}]}
	    fi # !dbg
	    if [ ${dbg_lvl} -ne 2 ]; then
		if [ -z "${par_opt}" ]; then
		    eval ${cmd_d2f[${fl_idx}]}
		    if [ "$?" -ne 0 ] || [ ! -f ${d2f_fl[${fl_idx}]} ]; then
			printf "${spt_nm}: ERROR Failed to convert double-precision to single-precision. Debug this:\n${cmd_d2f[${fl_idx}]}\n"
			exit 1
		    fi # !err
		else # !par_typ
		    eval ${cmd_d2f[${fl_idx}]} ${par_opt}
		    d2f_pid[${fl_idx}]=$!
		fi # !par_typ
	    fi # !dbg
	done # !fl_idx

	if [ -n "${par_opt}" ]; then
	    for ((fl_idx=fl_idx_srt;fl_idx<=fl_idx_end;fl_idx++)); do
		wait ${d2f_pid[${fl_idx}]}
		if [ "$?" -ne 0 ] || [ ! -f ${d2f_fl[${fl_idx}]} ]; then
		    printf "${spt_nm}: ERROR Failed to convert double-precision to single-precision. Debug this:\n${cmd_d2f[${fl_idx}]}\n"
		    exit 1
		fi # !err
	    done # !fl_idx
	fi # !par_opt
    fi # !d2f_flg

    if [ "${att_flg}" = 'Yes' ]; then
	# Block 4d: Add missing metadata to MPAS files unless script was invoked by ncclimo (it makes no sense to give naked files to ncclimo and then to annotate them here, so assume ncclimo is working with annotated files)
	for ((fl_idx=fl_idx_srt;fl_idx<=fl_idx_end;fl_idx++)); do
	    if [ ${vrb_lvl} -ge ${vrb_2} ]; then
		printf "att(in)  : ${fl_in[${fl_idx}]}\n"
		printf "att(out) : ${att_fl[${fl_idx}]}\n"
	    fi # !vrb_lvl
	    cmd_att[${fl_idx}]="${cmd_mpi[${fl_idx}]} ncatted -O -t -a _FillValue,,o,d,${mss_val} -a _FillValue,,o,f,${mss_val} \"${fl_in[${fl_idx}]}\" \"${att_fl[${fl_idx}]}\""
	    fl_in[${fl_idx}]="${att_fl[${fl_idx}]}"
	    if [ ${dbg_lvl} -ge 1 ]; then
		echo ${cmd_att[${fl_idx}]}
	    fi # !dbg
	    if [ ${dbg_lvl} -ne 2 ]; then
		if [ -z "${par_opt}" ]; then
		    eval ${cmd_att[${fl_idx}]}
		    if [ "$?" -ne 0 ] || [ ! -f ${att_fl[${fl_idx}]} ]; then
			printf "${spt_nm}: ERROR Failed to annotate MPAS file with _FillValue. Debug this:\n${cmd_att[${fl_idx}]}\n"
			exit 1
		    fi # !err
		else # !par_typ
		    eval ${cmd_att[${fl_idx}]} ${par_opt}
		    att_pid[${fl_idx}]=$!
		fi # !par_typ
	    fi # !dbg
	done # !fl_idx

	if [ -n "${par_opt}" ]; then
	    for ((fl_idx=fl_idx_srt;fl_idx<=fl_idx_end;fl_idx++)); do
		wait ${att_pid[${fl_idx}]}
		if [ "$?" -ne 0 ] || [ ! -f ${att_fl[${fl_idx}]} ]; then
		    printf "${spt_nm}: ERROR Failed to annotate MPAS file with _FillValue. Debug this:\n${cmd_att[${fl_idx}]}\n"
		    exit 1
		fi # !err
	    done # !fl_idx
	fi # !par_opt
    fi # !att_flg

    if [ "${prc_typ}" = 'rrg' ]; then 
	# Block 4e: RRG
	for ((fl_idx=fl_idx_srt;fl_idx<=fl_idx_end;fl_idx++)); do
	    rrg_dmn_lst=`ncdmnlst ${fl_in[${fl_idx}]} | grep ${rnm_sng}`
	    rrg_var_lst=`ncvarlst ${fl_in[${fl_idx}]} | grep ${rnm_sng}`
	    
	    dmn_sng=''
	    if [ -n "${rrg_dmn_lst}" ]; then
		for dmn in ${rrg_dmn_lst} ; do
		    dmn_sng="${dmn_sng} -d ${dmn},${dmn/${rnm_sng}/}"
		done # !dmn
	    else # !rrg_dmn_lst
		echo "ERROR: Regional regridding suffix string '${rnm_sng}' not found in any dimension names in ${fl_in[${fl_idx}]}"
		echo "HINT: Regional regridding input files must contain dimensions and variables whose names end with the ELM/CAM-SE created (from finclNlonlat namelist input) regional suffix string, e.g., '_128e_to_134e_9s_to_16s'. Valid regional suffix strings for this input file are:"
		eval "ncks -m ${fl_in[${fl_idx}]} | cut -d ':' -f 1 | cut -d '=' -s -f 1 | grep ncol | sed 's/ncol//' | sed -e 's/^ *//' -e 's/ *$//'"
		echo "Use exactly one of these strings as the argument to --rrg_rnm_sng"
		exit 1
	    fi # !rrg_dmn_lst
	    
	    var_sng=''
	    if [ -n "${rrg_var_lst}" ]; then
		for var in ${rrg_var_lst} ; do
		    var_sng="${var_sng} -v ${var},${var/${rnm_sng}/}"
		done # !rrg_var_lst
	    fi # !rrg_var_lst
	    
	    if [ ${vrb_lvl} -ge ${vrb_3} ]; then
		printf "RRG: Remove \"${rnm_sng}\" from dimension and variable names...\n"
	    fi # !vrb_lvl
	    cmd_rnm[${fl_idx}]="${cmd_mpi[${fl_idx}]} ncrename -O ${dmn_sng} ${var_sng} \"${fl_in[${fl_idx}]}\" \"${rnm_fl[${fl_idx}]}\""
	    fl_in[${fl_idx}]=${rnm_fl[${fl_idx}]}
	    if [ ${dbg_lvl} -ge 1 ]; then
		echo ${cmd_rnm[${fl_idx}]}
	    fi # !dbg
	    if [ ${dbg_lvl} -ne 2 ]; then
		if [ -z "${par_opt}" ]; then
		    eval ${cmd_rnm[${fl_idx}]}
		    if [ "$?" -ne 0 ] || [ ! -f ${rnm_fl[${fl_idx}]} ]; then
			printf "${spt_nm}: ERROR Failed to rename regional input file. Debug this:\n${cmd_rnm[${fl_idx}]}\n"
			exit 1
		    fi # !err
		else # !par_typ
		    eval ${cmd_rnm[${fl_idx}]} ${par_opt}
		    rnm_pid[${fl_idx}]=$!
		fi # !par_typ
	    fi # !dbg
	done # !fl_idx

	if [ -n "${par_opt}" ]; then
	    for ((fl_idx=fl_idx_srt;fl_idx<=fl_idx_end;fl_idx++)); do
		wait ${rnm_pid[${fl_idx}]}
		if [ "$?" -ne 0 ] || [ ! -f ${rnm_fl[${fl_idx}]} ]; then
		    printf "${spt_nm}: ERROR Failed to rename regional input file. Debug this:\n${cmd_rnm[${fl_idx}]}\n"
		    exit 1
		fi # !err
	    done # !fl_idx
	fi # !par_opt
	
	for ((fl_idx=fl_idx_srt;fl_idx<=fl_idx_end;fl_idx++)); do
	    if [ ${vrb_lvl} -ge ${vrb_3} ]; then
		printf "RRG: Append regional coordinates and vertices to renamed, annotated regional input data...\n"
	    fi # !vrb_lvl
	    cmd_apn[${fl_idx}]="${cmd_mpi[${fl_idx}]} ncks -A \"${rgn_fl}\" \"${rnm_fl[${fl_idx}]}\""
	    if [ ${dbg_lvl} -ge 1 ]; then
		echo ${cmd_apn[${fl_idx}]}
	    fi # !dbg
	    if [ ${dbg_lvl} -ne 2 ]; then
		if [ -z "${par_opt}" ]; then
		    eval ${cmd_apn[${fl_idx}]}
		    if [ "$?" -ne 0 ] || [ ! -f ${rnm_fl[${fl_idx}]} ]; then
			printf "${spt_nm}: ERROR Failed to append regional coordinates and vertices to annotated, regional input data. Debug this:\n${cmd_apn[${fl_idx}]}\n"
			exit 1
		    fi # !err
		else # !par_typ
		    eval ${cmd_apn[${fl_idx}]} ${par_opt}
		    apn_pid[${fl_idx}]=$!
		fi # !par_typ
	    fi # !dbg
	done # !fl_idx

	if [ -n "${par_opt}" ]; then
	    for ((fl_idx=fl_idx_srt;fl_idx<=fl_idx_end;fl_idx++)); do
		wait ${apn_pid[${fl_idx}]}
		if [ "$?" -ne 0 ] || [ ! -f ${rnm_fl[${fl_idx}]} ]; then
		    printf "${spt_nm}: ERROR Failed to append regional coordinates and vertices to annotated, regional input data. Debug this:\n${cmd_apn[${fl_idx}]}\n"
		    exit 1
		fi # !err
	    done # !fl_idx
	fi # !par_opt
    fi # !rrg

    if [ -n "${vrt_fl}" ]; then
	# Block 5a: Vertical interpolation
	for ((fl_idx=fl_idx_srt;fl_idx<=fl_idx_end;fl_idx++)); do

	    if [ ${vrb_lvl} -ge ${vrb_1} ]; then
		printf "Vertical : ${vrt_fl}\n"
	    fi # !vrb_lvl
	    out_fl=${fl_out[${fl_idx}]}
	    if [ "${flg_hrz}" = 'Yes' ]; then
		out_fl="${drc_tmp}/ncremap_tmp_out_vrt.${fl_idx}.nc"
	    fi # !flg_hrz
	    cmd_rgr[${fl_idx}]="${cmd_mpi[${fl_idx}]} ncks -O -t ${thr_nbr} ${nco_opt} ${nco_var_lst} ${vrt_opt} --vrt=\"${vrt_fl}\" \"${fl_in[${fl_idx}]}\" \"${out_fl}\""
	    fl_in[${fl_idx}]=${out_fl}
	    if [ ${dbg_lvl} -ge 1 ]; then
		echo ${cmd_rgr[${fl_idx}]}
	    fi # !dbg
	    if [ ${dbg_lvl} -ne 2 ]; then
		if [ -z "${par_opt}" ]; then
		    eval ${cmd_rgr[${fl_idx}]}
		    if [ "$?" -ne 0 ]; then
			printf "${spt_nm}: ERROR Failed to vertically interpolate. cmd_rgr[${fl_idx}] failed. Debug this:\n${cmd_rgr[${fl_idx}]}\n"
			exit 1
		    fi # !err
		else # !par_typ
		    eval ${cmd_rgr[${fl_idx}]} ${par_opt}
		    rgr_pid[${fl_idx}]=$!
		fi # !par_typ
	    fi # !dbg
	done # !fl_idx

	if [ -n "${par_opt}" ]; then
	    for ((fl_idx=fl_idx_srt;fl_idx<=fl_idx_end;fl_idx++)); do
		wait ${rgr_pid[${fl_idx}]}
		if [ "$?" -ne 0 ]; then
		    printf "${spt_nm}: ERROR Failed to vertically interpolate. cmd_rgr[${fl_idx}] failed. Debug this:\n${cmd_rgr[${fl_idx}]}\n"
		    exit 1
		fi # !err
	    done # !fl_idx
	fi # !par_opt
    fi # !vrt_fl
    
    if [ "${flg_hrz}" = 'Yes' ]; then
	# Block 5b: Horizontal regridding
	for ((fl_idx=fl_idx_srt;fl_idx<=fl_idx_end;fl_idx++)); do
	    if [ ${vrb_lvl} -ge ${vrb_1} ]; then
		printf "Map/Wgt  : ${map_fl}\n"
	    fi # !vrb_lvl
	    cmd_rgr[${fl_idx}]="${cmd_mpi[${fl_idx}]} ncks -O -t ${thr_nbr} ${nco_opt} ${nco_var_rgr} ${nco_var_lst} ${nco_msk_out} ${rgr_opt} --map_fl=\"${map_fl}\" \"${fl_in[${fl_idx}]}\" \"${fl_out[${fl_idx}]}\""
	    if [ ${dbg_lvl} -ge 1 ]; then
		echo ${cmd_rgr[${fl_idx}]}
	    fi # !dbg
	    if [ ${dbg_lvl} -ne 2 ]; then
		if [ -z "${par_opt}" ]; then
		    eval ${cmd_rgr[${fl_idx}]}
		    if [ "$?" -ne 0 ]; then
			printf "${spt_nm}: ERROR Failed to horizontally regrid. cmd_rgr[${fl_idx}] failed. Debug this:\n${cmd_rgr[${fl_idx}]}\n"
			exit 1
		    fi # !err
		else # !par_typ
		    eval ${cmd_rgr[${fl_idx}]} ${par_opt}
		    rgr_pid[${fl_idx}]=$!
		fi # !par_typ
	    fi # !dbg
	done # !fl_idx
	
	if [ -n "${par_opt}" ]; then
	    for ((fl_idx=fl_idx_srt;fl_idx<=fl_idx_end;fl_idx++)); do
		wait ${rgr_pid[${fl_idx}]}
		if [ "$?" -ne 0 ]; then
		    printf "${spt_nm}: ERROR Failed to horizontally regrid. cmd_rgr[${fl_idx}] failed. Debug this:\n${cmd_rgr[${fl_idx}]}\n"
		    exit 1
		fi # !err
	    done # !fl_idx
	fi # !par_opt
    fi # !flg_hrz
    
    # Regridding is complete so delete temporary files produced by this batch
    if [ "${cln_flg}" = 'Yes' ]; then
	for ((fl_idx=fl_idx_srt;fl_idx<=fl_idx_end;fl_idx++)); do
	    /bin/rm -f ${att_fl[${fl_idx}]} ${d2f_fl[${fl_idx}]} ${dpt_tmp_fl[${fl_idx}]} ${pdq_fl[${fl_idx}]} ${rnm_fl[${fl_idx}]} 
	    if [ -n "${vrt_fl}" ] && [ "${flg_hrz}" = 'Yes' ]; then
		# Remove vertically regridded intermediate output
		/bin/rm -f "${drc_tmp}/ncremap_tmp_out_vrt.${fl_idx}.nc"
	    fi # !vrt_fl
	done # !fl_idx
    fi # !cln_flg
	
    # Block 7: Parallel post-processing
    for ((fl_idx=fl_idx_srt;fl_idx<=fl_idx_end;fl_idx++)); do

	if [ -n "${prc_elm}" ]; then
	    if [ ${vrb_lvl} -ge ${vrb_3} ]; then
		printf "SGS: Implement idiosyncratic CLM/CTSM/ELM characteristics in regridded file...\n"
	    fi # !vrb_lvl
	    # Convert area from [sr] to [km2]
	    cmd_ppp[${fl_idx}]="ncap2 -O -s 'area*=${rds_rth}^2/1.0e6;area@long_name=\"Gridcell area\";area@units=\"km^2\"' \"${fl_out[${fl_idx}]}\" \"${fl_out[${fl_idx}]}\""
	    if [ ${dbg_lvl} -ge 1 ]; then
		echo ${cmd_ppp[${fl_idx}]}
	    fi # !dbg
	    if [ ${dbg_lvl} -ne 2 ]; then
		if [ -z "${par_opt}" ]; then
		    eval ${cmd_ppp[${fl_idx}]}
		    if [ "$?" -ne 0 ] || [ ! -f ${fl_out[${fl_idx}]} ]; then
			printf "${spt_nm}: ERROR Failed post-processing to convert output area from [sr] to [km2]. Debug this:\n${cmd_ppp[${fl_idx}]}\n"
			exit 1
		    fi # !err
		else # !par_typ
		    eval ${cmd_ppp[${fl_idx}]} ${par_opt}
		    ppp_pid[${fl_idx}]=$!
		fi # !par_typ
	    fi # !dbg
	fi # !prc_elm

	if [ -n "${prc_cice}" ]; then
	    if [ ${vrb_lvl} -ge ${vrb_3} ]; then
		printf "SGS: Implement idiosyncratic CICE characteristics in regridded file...\n"
	    fi # !vrb_lvl
	    # Convert area from [sr] to [m2], and aice from [frc] to [%]
	    cmd_ppp[${fl_idx}]="ncap2 -O -s 'area*=${rds_rth}^2;area@long_name=\"Gridcell area\";area@units=\"m^2\";${sgs_frc}*=100;${sgs_frc}@units=\"%\"' \"${fl_out[${fl_idx}]}\" \"${fl_out[${fl_idx}]}\""
	    if [ ${dbg_lvl} -ge 1 ]; then
		echo ${cmd_ppp[${fl_idx}]}
	    fi # !dbg
	    if [ ${dbg_lvl} -ne 2 ]; then
		if [ -z "${par_opt}" ]; then
		    eval ${cmd_ppp[${fl_idx}]}
		    if [ "$?" -ne 0 ] || [ ! -f ${fl_out[${fl_idx}]} ]; then
			printf "${spt_nm}: ERROR Failed post-processing to convert output area from [sr] to [m2] and ${sgs_frc} from [frc] to [%]. Debug this:\n${cmd_ppp[${fl_idx}]}\n"
			exit 1
		    fi # !err
		else # !par_typ
		    eval ${cmd_ppp[${fl_idx}]} ${par_opt}
		    ppp_pid[${fl_idx}]=$!
		fi # !par_typ
	    fi # !dbg
	fi # !prc_cice

	# Block 8: Other special case post-processing
	if [ "${prc_typ}" = 'hirdls' ] || [ "${prc_typ}" = 'mls' ]; then
	    # NB: Move file to avert problem with --no_tmp_fl causing self-overwrite
	    # fxm: ncwa_fl is not parallel-safe, needs fl_idx suffix
	    cmd_ppp[${fl_idx}]="/bin/mv \"${fl_out[${fl_idx}]}\" \"${ncwa_fl}\";ncwa -O -a lon ${nco_opt} ${nco_var_lst} \"${ncwa_fl}\" \"${fl_out[${fl_idx}]}\""
	    # Block 7 Loop 2: Execute and/or echo commands
	    if [ ${dbg_lvl} -ge 1 ]; then
		echo ${cmd_ppp[${fl_idx}]}
	    fi # !dbg
	    if [ ${dbg_lvl} -ne 2 ]; then
		if [ -z "${par_opt}" ]; then
		    eval ${cmd_ppp[${fl_idx}]}
		    if [ "$?" -ne 0 ] || [ ! -f ${fl_out[${fl_idx}]} ]; then
			printf "${spt_nm}: ERROR Failed post-processing to generate zonal file from lat-lon file. Debug this:\n${cmd_ppp[${fl_idx}]}\n"
			exit 1
		    fi # !err
		else # !par_typ
		    eval ${cmd_ppp[${fl_idx}]} ${par_opt}
		    ppp_pid[${fl_idx}]=$!
		fi # !par_typ
	    fi # !dbg
	fi # !znl
    done # !fl_idx

    # Block 9: Wait for post-processing tasks to complete
    if [ -n "${par_opt}" ]; then
	for ((fl_idx=fl_idx_srt;fl_idx<=fl_idx_end;fl_idx++)); do
	    wait ${ppp_pid[${fl_idx}]}
	    if [ "$?" -ne 0 ]; then
		printf "${spt_nm}: ERROR Failed post-processing step cmd_ppp[${fl_idx}]. Debug this:\n${cmd_ppp[${fl_idx}]}\n"
		exit 1
	    fi # !err
	done # !fl_idx
    fi # !par_opt

done # !bch_idx

if [ "${cln_flg}" = 'Yes' ]; then
    if [ ${vrb_lvl} -ge ${vrb_3} ]; then
	printf "Clean-up intermediate files...\n"
    fi # !vrb_lvl

    /bin/rm -f ${dmm_fl} ${grd_dst_dfl} ${grd_src_dfl} ${hnt_dst_fl} ${hnt_src_fl} ${map_fl_dfl} ${map_trn_fl} ${msh_fl_dfl} ${ncwa_fl} ${nnt_fl} ${rgn_fl} ${tmp_out_fl} ${znl_fl/znl/znl1} ${znl_fl/znl/znl2}
else # !cln_flg
    if [ ${vrb_lvl} -ge ${vrb_3} ]; then
	printf "Explicitly instructed not to clean-up intermediate files\n"
    fi # !vrb_lvl
fi # !cln_flg

date_end=$(date +"%s")
if [ ${vrb_lvl} -ge ${vrb_3} ]; then
    if [ ${fl_nbr} -eq 0 ]; then
	printf "Completed generating map/grid-file(s) at `date`.\n"
    else # !fl_nbr
	echo "Quick plots of results from last regridded file:"
	echo "ncview  ${out_fl} &"
	echo "panoply ${out_fl} &"
    fi # !fl_nbr
    date_dff=$((date_end-date_srt))
    echo "Elapsed time $((date_dff/60))m$((date_dff % 60))s"
fi # !vrb_lvl

exit 0
